syntax = "proto2";
option java_package = "cloudwan.cpe.proto.protopojo";
option java_multiple_files = true;
message PayloadType {
    required uint32                 netId           = 1;
    optional uint32                 transactionId   = 2;
    optional uint32                 errorCode       = 3;        // for Reply and ErrorReport message
    optional BaseType                msgBase         = 4;
    optional string                 businessKey     = 5;
    optional string                 errorMsg        = 6;
    optional bool                   isNormalMsg     = 7;
    optional FragInfo               fragInfo        = 8;
}

message FragInfo {
    required uint32                 fragSeq         = 1;
    required bool                   endFlag         = 2;
}

message AllConfStart_O2C {

}

message AllConfEnd_O2C {

}

message BaseType {
    optional Login_C2O              login           = 1;        // chenxu & zhenli
    optional Heartbeat_C2O          heartbeat       = 2 [deprecated=true];        // chenxu & zhenli
    optional AllConfStart_O2C       AllConfStart    = 3;        // chenxu & yunpeng
    optional AllConfEnd_O2C         AllConfEnd      = 4;        // chenxu & yunpeng
    optional BgpSoftReset_O2C       bgpSoftReset    = 5;
    optional BgpHardReset_O2C       bgpHardReset    = 6;
    optional InterfaceReport_C2O    interfaceReport = 11;       // chenxu & zhenli
    optional LinkReport_C2O         linkReport      = 12;       // qingjie & zhenli
    optional ConnReport_C2O         connReport      = 13;       // qingjie & zhenli
    optional HAInterfaceReport_C2O  haInterfaceReport = 14;     // chenxu & yunpeng
    optional DynRouteReport_C2O     dynRouteReport  = 21;       // zhiliang & yunpeng
    optional RouteRequest_C2O       routeRequest    = 22;       // zhiliang & yunpeng
    optional Route_O2C              route           = 23;       // zhiliang & yunpeng
    optional BgpStatsReport_C2O     bgpStatsreport  = 24;       // zhiliang & yunpeng

    repeated StatsReportV2_C2O      statsReportV2   = 30;
    optional StatsReport_C2O        statsReport     = 31;       // chenxu & lipeng
    optional AccessAuditReport_C2O  accessAuditReport = 32;     // jackie
    optional FlowReport_C2O         flowReport      = 33;
    optional RatelimitReport_C2O    ratelimitReport = 34;       // chenxu & zhenli
    optional DiagnoseReport_C2O     diagnoseReport  = 35;       // chenxu & zhenli
    optional MeetingReport_C2O      meetingReport = 36;       // chenxu & lipeng
    optional PopDCpeReport_C2O      popDCpeReport   = 37;       // jackie
    optional PopDCpeClientStatusReport_C2O      popDCpeClientReport   = 38;       // jackie
    optional PopDCpeSupportReport_C2O           popDCpeSupportReport  = 39;       // jackie
    optional PopDCpeClientStatusPeriodicReport_C2O    popDCpeClientPeriodReport  = 40;
    optional DomainAuditReport_C2O  domainAuditReport = 41;
    optional IpsecConfigReport_C2O  ipsecConfigReport = 42;
    optional IpsecConnectionConfigReport_C2O    ipsecConnConfReport = 43;
    optional IpsecConnectionStatusReport_C2O    ipsecConnStatReport = 44;
    optional VirtualSwitchConfigReport_C2O      vSwitchConfReport = 45;
    optional LanTemplateReport_C2O              lanTemplateReport = 46;
    optional ClusterManagerReport_C2O clusterManagerReport = 47;
    optional NatAuditReport_C2O natAuditReport = 48;
    optional EnableVPNReport_C2O enableVPNReport = 49;
    optional ClusterStatusReport_C2O clusterStatusReport = 50 ;

    optional Configure_O2C          configure       = 100;      // All
    optional ConfigureReply_C2O     configureReply  = 102;      // chenxu
    optional IpDetect_O2C           ipDetect        = 103;      // chenxu & vincent
    optional IpDetectReply_C2O      ipdetectReply   = 104;      // chenxu & vincent
    optional UpgradeNotify_O2C      upgradeNotify   = 105;      // chenxu & vincent
    optional UpgradeNotifyReply_C2O upgradeNotifyReply = 106;   // chenxu & vincent
    optional UpgradeResult_C2O      upgradeResult   = 107;      // chenxu & vincent
    optional AUConfigResult_C2O     auConfigResult  = 108;      // yunpeng & chenxu
    optional CpeUnreachNotify_O2C   cpeUnreachNotify= 109;      // yunpeng & xiaoyun
    optional SynDynRouteVersion_C2O synDynRouteVersion  = 110;  // yunpeng & xiaoyun
    optional ProbeResult_C2O        probeResult     = 111;      // chenxu & zhangyang
    optional DistRatelimitBonus_O2C ratelimitBonus  = 112;      // chenxu & zhenli
    optional Diagnose_O2C           diagnose        = 113;      // chenxu & zhenli
    optional SshInfo_O2C            sshInfo         = 114;      // chenxu & zhenli
    optional TermProbeResult_O2C    termProbeResult = 115;      // chenxu & zhangyang
    optional TermProbeResultReply_C2O termProbeResultReply = 116;//chenxu & zhangyang
    optional Keepalive_O2C          keepalive       = 117;      // chenxu & zhenli
    optional AcceServStatReport_C2O acceServStats   = 118;      // chenxu & yuheng
    optional MobileAuthInfo_O2C     mobileAuth      = 119;      // yuheng & ziwei
    optional MobileAuthResult_C2O   mobileAuthResult= 120;      // yuheng & ziwei
    optional CpeReachStateReport_C2O  cpeReachStateReport = 121; // xzhao & yunpeng
    optional DynRouteMixReport_C2O  dynRouteMixReport = 122;    // xzhao & yunpeng
    optional DynRouteMixPush_O2C    dynRouteMixPush   = 123;     // xzhao & yunpeng
    optional CsvrChangeNotify_O2C   csvrChangeNotify  = 124;
    optional CpeRestartNotify_O2C   cpeRestartNotify  = 125;
    optional WirelessWanReport_C2O  wwanReport        = 126;
    optional LdapSyncOU_O2C         ldapSyncOu        = 127;
    optional LdapSyncOUResult_C2O   ldapSyncOuResult  = 128;

    optional GatewayAuthConf_O2C  gatewayAuthConf     = 160;
    optional GatewayAuthAuditReport_C2O  gatewayAuthAuditReport           = 161;
    optional RemoteAccessAuthAuditConf_O2C  remoteAccessAuthAuditConf     = 162;
    optional RemoteAccessAuthAuditReport_C2O  remoteAccessAuthAuditReport = 163;
    optional FaultReport_C2O faultReport              = 164;
    optional SshProxyReport_C2O sshProxyReport        = 165;
    optional ArpTblReport_C2O arpTblReport            = 166;
    optional WirelessWanNetworkStatusReport_C2O wirelessWanNetworkStatusReport = 167;

    optional CryptoMsg cryptoMsg                      = 170;
    optional TaskResult_C2O  taskResult               = 171;
    optional LdapCheckAuth_O2C checkAuth              = 172;
    optional LdapCheckAuth_C2O checkAuthResult        = 173;
    optional GatewayAuthConfResult_C2O gatewayConfResult = 174;
    optional DiagUploadReq_C2O diagnoseUploadRequest  = 175;
    optional PeerSitePolicyStateReport_C2O peerSitePolicyStateReport = 176;
    optional WanUseDefaultShaperReport_C2O wanUseDefaultShaperReport = 177;
    optional WifiStationStatusReport_C2O wifiStationStatusReport     = 178;
    optional EmbeddedDevIntranetModeReport_C2O embeddedDevIntranetModeReport  = 179;
    optional SecurityInstanceStatusReport_C2O securityInstanceStatusReport = 180;
    optional FlowAuditReport_C2O  flowAuditReport = 181;
    optional PolicyProbeReport_C2O  policyProbeReport = 182;

    optional LdapSyncReq_O2C    ldapSyncReq    = 187;
    optional LdapSyncReply_C2O  ldapSyncReply  = 188;
    optional AlarmReport_C2O    alarmReport    = 189;
    optional BlockListReport_C2O    blockListReport = 190;
    optional LogReport_C2O          LogReport       = 191;
    optional AtkItemRequest_C2O     atkItemRequest  = 192;
    optional IpsItemRequest_C2O     ipsItemRequest  = 193;
    optional AvItemRequest_C2O      avItemRequest   = 194;
    optional ComwarePolicyNameReport_C2O comwarePolicyName = 195;
    optional HARunningStateReportC2O haRunningStateReport = 196;
}

message PolicyProbeReport_C2O {
    repeated PolicyProbeItem            policyProbeItem = 1;
}

message PolicyProbeItem {
    required uint32                     customerId      = 1;
    required uint32                     policyId        = 2;
    repeated PolicyProbeOutPortResult   outPort         = 3;
}

message PolicyProbeOutPortResult {
    required uint32                     outPortType     = 1;
    required uint32                     outPortId       = 2;
    optional ConnId                     outPortConn     = 3;
    required uint32                     errCode         = 4;
    required uint32                     latency         = 5;   // smooth latency
    required uint32                     jitter          = 6;   // smooth jitter
    required uint32                     pktLoss         = 7;   // smooth pkt loss
    required uint32                     realtimeLatency = 8;   // realtime latency
    required uint32                     realtimeJitter  = 9;   // realtime jitter
    required uint32                     realtimePktLoss = 10;  // realtime pkt loss
}

message HARunningStateReportC2O {
    required uint32                 role            = 1;   // 0-master 1-slave others-fault
    repeated HAInstanceState        instState       = 2;   // repeated for multi HA heartbeat if (one if one inst)
}

message HAInstanceState {
    required uint32                 vrId            = 1;
    required uint32                 priority        = 2;
}

message FlowAuditReport_C2O {
    repeated FlowAuditItem          flowAuditItem   = 1;
}

message FlowAuditItem {
    required FourTuple              originalTuple   = 1;
    optional FourTuple              natTuple        = 2;
    required uint32                 natType         = 3;
    required uint32                 protocol        = 4;
    required bool                   accessedFlag    = 5;
    required bool                   relatedFlag     = 6;
    required uint32                 inPortType      = 7;
    required uint32                 inPortId        = 8;
    required uint32                 outPortType     = 9;
    required uint32                 outPortId       = 10;
    required uint32                 vpnId           = 11;
    required uint32                 customerId      = 12;
    required uint32                 policyId        = 13;
    required uint64                 accessTime      = 14;
    optional string                 domain          = 15;
    required uint32                 auditType       = 16;   // 1-Necessary 2-Normal
    optional ConnId                 inPortConn      = 17;
    optional ConnId                 outPortConn     = 18;
}

message FourTuple {
    required NetAddr                srcIp           = 1;
    required NetAddr                dstIp           = 2;
    required uint32                 srcPort         = 3;
    required uint32                 dstPort         = 4;
}

message EmbeddedDevIntranetModeReport_C2O {
    required uint32 id                              = 1;        // identifier of this config
    required uint32 result                          = 2;

}


message ItemRequestCommon {
    required string                 id               = 1;
    optional uint64                 version          = 2;
}

message AtkItemRequest_C2O {
    repeated ItemRequestCommon      atkItem         = 1;
}

message IpsItemRequest_C2O {
    repeated ItemRequestCommon      ipsItem         = 1;
}

message AvItemRequest_C2O {
    repeated ItemRequestCommon      avItem         = 1;
}

message ComwarePolicyNameReport_C2O {
    required uint32 policyId                       = 1;
    required uint32 type                           = 2;   //1 ATK 2 IPS 3 AV 4 URL 5 DFILTER 6 FFILTER 7 APT 8 WAF 9 SSL
    required string comwarePolicyName              = 3;   //string length 1-63
}

message DimLogItem {
    required uint64 logTimeStamp = 1;
    required uint32 threatId = 2;
    required string threatName = 3;
    required uint32 severity = 4;         //  LOW = 0, Medium = 1,High = 2, Critical  = 3
    optional string interfaceName = 5;   //  e.g: lan 1  wan1
    optional string realSourceIpAddress = 6;
    optional string sourceIpAddress = 7;
    optional uint32 sourcePort = 8;
    optional string destinationIpAddress = 9;
    optional uint32 destinationPort = 10;
    optional string application = 11;
    optional string protocol = 12;
    optional string fileName = 13;
    optional string loginUsername = 14;
    optional string loginPassword = 15;
    optional uint32 action = 16;   //  0 Blackdlist  1 Drop 2 Permit 3 Reset 4 Redirect
    optional string contentSecurityPolicy = 17;
    optional string attackClassification = 18;
    optional string attackSubclassification = 19;
    optional string sourceUser = 20;
    optional string cve = 21;
    optional string bid = 22;
    optional string msb = 23;
    optional string domainName = 24;
    optional string messageHeaderField = 25;
    optional string messageFirstLine = 26;
    optional string captureName = 27;
    optional string eventReturnParameters = 28;
    optional uint32 vni = 29;
    optional uint32 vlanId = 30;
    optional string sourceRegion = 31;
    optional string destinationRegion = 32;
    optional string sourceMacAddress = 33;
    optional string destinationMacAddress = 34;
    optional string realSourceMacAddress = 35;
    optional string realDestinationMacAddress = 36;
    optional uint32 policyId = 37;
    optional string itemName = 38;
}

message AtkLogItem {
    required uint64 currenTimeStamp = 1;
    required uint32 severity = 2;          // 0 emergency 1 alert 2 critical 3 error 4 warning 5 notification 6 informational 7 debugging
    optional string singlePacketAttackType = 3;
    optional uint32 floodType = 4;
    optional uint32 scanType = 5;
    optional uint32 actionType = 6;        //0x01 logging  0x02 drop 0x04 block-source 0x08 client-verify
    optional string vpnName = 7;
    optional string interfaceName = 8;   //  e.g: lan 1  wan1
    optional string destinationIpAddress = 9;
    optional string sourceIpAddress = 10;
    optional uint64 attackStartTimeStamp = 11;
    optional uint64 attackEndTimeStamp = 12;
    optional uint32 attackCount = 13;
    optional uint32 icmpType = 14;
    optional uint32 ipOptions = 15;
    optional string protocolType = 16;
    optional uint32 ipv6ExtensionHeadersLimit = 17;
    optional uint32 rateLimit = 18;
    optional uint32 policyId = 19;
    optional string itemName = 20;
}

message LogReport_C2O {
    required uint32      logType    = 1;    // SinglePacketAttack = 0, ScanAttack = 1,FloodAttack = 2, Ips = 3, Av = 4
    repeated AtkLogItem  atkLogItem = 2;    // The log item of SinglePacketAttack , ScanAttack ,FloodAttack are the same
    repeated DimLogItem  ipsLogItem = 3;
    repeated DimLogItem  avLogItem  = 4;
}

message BlockListReport_C2O {
    repeated BlockListItem          blockListItem = 1;
}

message TaskResult_C2O {
    required uint32 moduleId                        = 1;
    required uint32 status                          = 2;
    optional uint32 errorId                         = 3;
    optional string msg                             = 4;
}

message ArpTblItem {
    required string                 ifName            = 1;
    required uint32                 ipv4              = 2;
    required string                 macAddr           = 3;
    required uint32                 hwType            = 4;
    required uint32                 flags             = 5;
}

message ArpTbl {
    required uint32                 vpnId             = 1;
    repeated ArpTblItem             arps              = 2;
}

message ArpTblReport_C2O {
    required uint32                 totalArpNum       = 1;      // Total arp number from public zone and security zone.
    repeated ArpTbl                 arpTbl            = 2;
}


message SshProxyReport_C2O {
    required bool                   running           = 1;      // frpc is running or not.
}

message WirelessWanReport_C2O {
    required uint32                 wanId             = 1;
    required uint32                 plmnCode          = 2;      // reference to ITU-T E.212 MCC/MNC database
    optional uint32                 accessTechnology  = 3;      // reference to LW_WWAN_ACCESS_TECHNOLOGY
}

message FaultReport_C2O {
    required uint32                 ReportType          = 1;    // LW_CLIENT_FAULT_REPORT
    optional FaultReportPPPoE       PPPoEFaultReport    = 2;
    optional FaultReportAgentHung   AgentHungReport     = 3;
    optional FaultReportDupMac      DupMacReport        = 4;
}

message FaultReportPPPoE {
    required string                 IfName              = 1;
    optional uint32                 Type                = 2;    // LW_PPPOE_FAULT_TYPE
    optional uint32                 WanId               = 3;
}

message FaultReportAgentHung {
    required string ThreadName      = 1;
}

message CpeInfo {
    required uint32                 CustomerId          = 1;
    required uint32                 ClientId            = 2;
    optional uint32                 VpnId               = 3;
}

message DupMacItem {
    required uint32                 Type                = 1;    //LW_DUP_MAC_DETECT_TYPE
    required string                 macAddr             = 2;
    repeated CpeInfo                CpeInfo             = 3;
}

message FaultReportDupMac {
    repeated DupMacItem             DupMac              = 1;
}

message GatewayAuthConf_O2C {
    required bool                   enable              = 1;
    optional WinRadiusConfig        radiusServerConf    = 2;
    optional AllowedRuleSet         ruleSet             = 3; //exempt source IP addresses
    optional uint32                 errorHandle         = 4; //Reserved, error handling(RADIUS Server is faulty and offline) behavior block/permit.
    optional string                 downloadUrl         = 5; //Download URL for auth php
    optional uint32                 flowTimeout         = 6; //minutes
    optional AllowedRuleSet         exemptDests         = 7; //exempt Dest IP addresses
    optional string                 checksum            = 8; //md5 checksum for auth php suite tarball
}

message GatewayAuthConfError {
    required uint32                 confItem            = 1;
    optional uint32                 errorCode           = 2;
}

message GatewayAuthConfResult_C2O {
    required uint32                 enabled             = 1; //Indicate whether gateway auth is enabled
    repeated GatewayAuthConfError   confError           = 2;
}

message RemoteAccessAuthAuditConf_O2C {
    required bool                   enable              = 1;
    optional NetAddr                listenAddr          = 2;
    optional uint32                 listenPort          = 3;
}

message WinRadiusConfig {
    required string                 authMethod       = 1;   //EAP-MSCHAPV2/MS-CHAP/CHAP/PAP
    repeated string                 authServer       = 2;   //host:port:secret e.g 127.1.1.1:5050:TEST
    required string                 authOrder        = 3;   //radius,local
    required uint32                 loginTries       = 4;   //maximum login tries
    required uint32                 loginTimeout     = 5;   //timeout for all login tries
    required uint32                 radiusTries      = 6;   //resend request this many times before trying the next server
    required uint32                 radiusTimeout    = 7;   //time to wait for a reply from the RADIUS server
    optional string                 defaultRealm     = 8;   //default authentication realm to append to all usernames
    repeated RadiusAttribute        attributes       = 9;   //attributes for authentication  e.g key(4) value(1.1.1.1/32) for NAS-IP Address = 1.1.1.1/32
}

message RadiusAttribute {
    required uint32                 key      = 1;   //IETF Attributes
    required string                 value    = 2;
}

message AllowedRuleSet {
    repeated string                 ipWithMask       = 1;
}

message GatewayAuthAuditReport_C2O {
    repeated GatewayAuthAuditStats  gatewayAuthAuditStats = 1;
}

message GatewayAuthAuditStats {
    required bool                   success          = 1;
    required string                 userName         = 2;
    required NetAddr                userAddr         = 3;
    required uint64                 timestamp        = 4;
}

message RemoteAccessAuthAuditReport_C2O {
    repeated RemoteAccessAuthAuditStats  accessAuthAuditStats = 1;
}

message RemoteAccessAuthAuditStats {
    required string                 userName         = 1;
    required uint64                 timestamp        = 2;
    optional uint32                 packetType       = 3;   // 1 = Access-Request 2 = Access-Accept 3 = Access-Reject 4 = Accounting-Request
    optional NetAddr                userAddr         = 4;
    optional NetAddr                acAddr           = 5;
}

message CpeRestartNotify_O2C {
    required uint32                 restartOp         = 1;       // 0:restart CPE service 1ï¼šreboot device
}

//It is an empty message, ONLY for keep-alive
message Keepalive_O2C {

}

message TermProbeResult_O2C {
    required string                 termProbeResult = 1;
}

message TermProbeResultReply_C2O {
    required uint32                 errorCode       = 1;
}

message SshInfo_O2C {
    optional string                 customerName    = 1;        // Only for CPE
    optional string                 siteName        = 2;        // Only for CPE
    optional string                 orchAddr        = 3;        // Only for POP
    optional string                 popName         = 4;        // Only for POP
    optional string                 popRegion       = 5;        // Only for POP
    optional uint32                 cpeId           = 6;        // Only for CPE
    optional string                 cpeName         = 7;        // Only for CPE
}

message MeetingReport_C2O {
    required string                 serialNo        = 1;
    required string                 reportInfo      = 2;        // json string from yunshixun terminal
}

message IntfCapCondition {
    repeated string                 srcHost         = 1;        // host(src or dst) include single ip(192.168.1.1), ip with mask(192.168.0.0/24), domain(www.google.com)
    repeated string                 dstHost         = 2;
    repeated uint32                 srcPort         = 3;
    repeated uint32                 dstPort         = 4;
    repeated string                 protocol        = 5;        // protocol such as "tcp", "udp", "icmp", "vrrp" ...
    optional string                 ifname          = 6;        // ifname is null means cap all interfaces
    repeated Range                  srcPortRange    = 7;
    repeated Range                  dstPortRange    = 8;
    optional uint32                 srcDstLogic     = 9;        // src and dst logic relationship ("or","and") LW_DIAGNOSE_INTF_PCAP_LOGIC_RELATIONSHIP
}

message IntfPktCapConf {
    required string                 pktCapId        = 1;        // pkt cap task unique id
    required uint32                 pktCapOp        = 2;        // LW_PKT_CAP_OP
    required uint32                 timeout         = 3;        // second. Timeout for pkt cap.
    repeated IntfCapCondition       intfCapCondition= 4;        // cap pkt condition
    required uint32                 fileSize        = 5;        // (MB) each pcap file size
    required uint32                 fileCount       = 6;        // pcap file number
    optional uint32                 snapLen         = 7;        // every pkt len
}

message LogFile {
    required string                 logId           = 1;        // id of uploading log
    required string                 uploadUrl       = 2;        // use this url to upload log file
    required uint64                 urlExpiredTime  = 3;        // expired timestamp of url  without feature LW_ORCH_FEATURE_DIAGNOSE_ASYNC
    required uint32                 urlMethod       = 4;        // LW_HTTP_METHOD
    required uint32                 level           = 5;        // log level: info, warning, error (unused for now)
    required bool                   all             = 6;        // whether to collect all diagnose log (LW_DIAGNOSE_LOG(0) is true, others is false)
    repeated uint32                 content         = 7;        // what content need to be collected when all is false (unused for now)
    optional uint32                 logDuration     = 8;        // second. default is 1 days
    optional uint32                 urlTimeout      = 9;        // second. url timeout with feature LW_ORCH_FEATURE_DIAGNOSE_ASYNC
}

message DcpeLogFile {
    required string                 dcpeLogId       = 1;        // dcpe log file unique id;
    repeated string                 dcpeName        = 2;        // dcpe names;
}

message DiagUploadReq_C2O {
    required uint32                 type            = 1;        // LW_DIAGNOSE_TYPE
    required string                 logId           = 2;        // id of uploading log
}

message ConnPktCapConf {
    required uint32                 vni             = 1;
    required uint32                 label           = 2;
    optional string                 pktCapId        = 3;
    optional uint32                 pktCapOp        = 4;        // LW_PKT_CAP_OP
    optional uint32                 duration        = 5;        //second
    optional uint32                 fileSize        = 6;        // (MB) each pcap file size
    optional uint32                 fileCount       = 7;        // pcap file number
    optional uint32                 snapLen         = 8;        // every pkt len
}

message Diagnose_O2C {
    required uint32                 type            = 1;        // LW_DIAGNOSE_TYPE
    optional LogFile                logfile         = 2;        // {required} requirement of log file by http(https) uploading.
    optional IntfPktCapConf         intfPktCap      = 3;        // Business configuration for LW_DIAGNOSE_INTF_PKT_CAP(2)
    optional DcpeLogFile            dcpeLogFile     = 4;        // When dcpe is offline, collect dcpe log file. For LW_DIAGNOSE_OFF_LINE_DCPE_LOG(3)
    optional ConnPktCapConf         connPktCap      = 5;        // Business configuration for LW_DIAGNOSE_CONNECTION_PKT_CAP(4)
    optional uint32                 operation       = 6;        // 1: diagnosis action 2: upload diagnosis result.
}

message EngineDiagReport {
    required uint32                 srcIP           = 1;
    required uint32                 dstIP           = 2;
    required uint32                 srcPort         = 3;
    required uint32                 dstPort         = 4;
    required uint32                 proto           = 5;
    required uint64                 startTime       = 6;        // the flow start timestamp in msec.
    required uint64                 lifeTime        = 7;        // the total lifetime in millisec.
    required uint32                 handShake       = 8;        // the handshake time in millisec.
    required uint32                 srtt            = 9;        // the SRTT in millisec.
    required uint32                 txFactor        = 10;       // use with LossFactor for loss rate.
    required uint32                 lossFactor      = 11;       // use with TxFactor for loss rate.
    required uint64                 txDataBytes     = 12;       // the transmitted data bytes.
    required uint64                 rxDataBytes     = 13;       // the received data bytes.
}

message LogFileResult {
    required string                 logId           = 1;        // id of uploading log
    required bool                   uploaded        = 3;        // true: upload successfully, false: upload fail
    optional uint64                 fileSize        = 2;        // file size (byte)
    optional uint64                 uploadedTime    = 4;        // uploaded timestamp
    optional uint32                 reason          = 5;        // error code when upload fail
}

message DiagnoseReport_C2O {
    repeated EngineDiagReport       engineReport    = 1 [deprecated=true];
    optional uint32                 type            = 2;        // LW_DIAGNOSE_TYPE
    optional LogFileResult          logfile         = 3;        // result for LW_DIAGNOSE_LOG(0), LW_DIAGNOSE_INTF_PKT_CAP(2)
}

message CrashInfo {
    required bool                   agentCrash      = 1;        // true means agent crash, false means datapath crash
    required string                 crashFileName   = 2;        // crash file name
    required uint32                 timestamp       = 3;        // second
}

message HardwareInfo {
    required uint32                 cpuCoreNum      = 1;        // cpu core number
    required uint32                 totalMem        = 2;        // total memory in MiB
}

message MobileInfo {
    required string                 sn              = 1;
    required string                 token           = 2;
}

message CurWanGw {
    required uint32                 wanId           = 1;
    required NetAddr                gwAddr          = 2;
}

message Login_C2O {
    required string                 version         = 1;
    optional uint64                 timestamp       = 2;
    optional string                 serialNo        = 3;
    optional uint64                 koTimestamp     = 4;        // s
    optional uint32                 haMode          = 5;        // 0: ha disable 1: ha master 2: ha slave
    repeated uint32                 features        = 6;        // supported features report for compatibility
    repeated CrashInfo				crashInfo       = 7;        // agent crash or datapath crash
    optional HardwareInfo           hardwareInfo    = 8;        // hardware infomation
    optional MobileInfo             mobileInfo      = 9;        // report sn and token to Orch
    optional bool                   restartFlag     = 10;       // CPE or POP restart flag
    optional bool                   persistRecover  = 11;       // Agent has recovered configuration from database.
    optional CsvrSwitchInfo         csvrSwitchInfo  = 12;
    repeated CurWanGw               curWanGws       = 13;
    optional string                 isoVersion      = 14;
    optional string                 thirdPatchVersion      = 15;
    optional string                 driverPatchVersion     = 16;
    optional string                 cryptoDevSN          = 17;
    optional bool                   cryptoCardUnhealthy     = 18;
    optional uint32                 cryptoEquipType      = 19;        // LW_CRYPTO_EQUIP_TYPE
}

message CsvrSwitchInfo {
    required CsvrAddr               originalCsvr    = 1;
    required CsvrAddr               currentCsvr     = 2;
    required uint32                 reason          = 3;        // 0 : csvr unreachable 1 : orch unreachable
}

message CsvrAddr {
    required string                 addr        = 1;        // Dotted Decimal ipv4 / Hexadecimal ipv6 / domain
    required uint32                 port        = 2;
}

message Heartbeat_C2O {
    repeated BandwidthStats         bandwidthStats  = 1;        // old msg item: "wan_bw_report"
}

message BandwidthStats {
    required uint32                 wanId           = 1;
    required uint32                 inbound         = 2;        // bps
    required uint32                 outbound        = 3;        // bps
}

message InterfaceReport_C2O {
    required uint32                 ifStatus        = 1;        // LW_IF_STATUS
    required uint32                 wanId           = 2;
    required string                 ifName          = 3;
    repeated Cidr                   ipList          = 4;
    optional uint32                 seqID           = 5;
    repeated uint32                 dnsList         = 6;
    optional uint32                 gateway         = 7;
    optional uint32                 lanId           = 8;
    repeated Ipv6Cidr               ipv6List        = 9;
    repeated bytes                  ipv6DnsList     = 10;
    optional bytes                  ipv6Gateway     = 11;
    optional WWanAlert              wwanAlert       = 12;
    optional uint32                 vlanId          = 13;       // for loopback probe
    repeated uint32                 dnsStatusList   = 14;       // LW_DNS_STATUS_TYPE
}

message WWanAlert {
    required uint32                 alertType       = 1;        // LW_WWAN_ALERT_TYPE
    required uint32                 moduleModel     = 2;        // LW_WWAN_MODULE_MODEL_TYPE
    optional WWanAlertCrash         wwanAlertCrash  = 3;
}

message WWanAlertCrash {
    required uint32                 timeStamp       = 1;        // seconds
    required uint32                 crashFileFlag   = 2;        // 0 means no need to collect, 1 means log collection succee,  2 means fail
    optional string                 crashFileName   = 3;        // crash file name
}

message HAInterfaceReport_C2O {
    required uint32                 ifStatus        = 1;        // LW_IF_STATUS
    required string                 ifName          = 2;
    required uint32                 seqID           = 3;
}

message LinkReport_C2O {
    required uint32                 notifyType      = 1;
    required uint32                 value           = 2;
    required uint32                 linkId          = 3;
    required string                 linkType        = 4;
}

message ConnReport_C2O {
    required uint32                 notifyType      = 1;
    required uint32                 value           = 2;
    required uint32                 label           = 3;
    required uint32                 vni             = 4;
    optional uint32                 sessionId       = 5;
    optional uint32                 srcIP           = 6;
    optional uint32                 dstIP           = 7;
    optional uint32                 policyID        = 8;
    optional uint32                 srcPort         = 9;
    optional uint32                 dstPort         = 10;
    optional uint32                 mode            = 11;
    optional uint32                 buddyId         = 12;
    optional bytes                  srcIpv6         = 13;
    optional bytes                  dstIpv6         = 14;
    optional uint32                 ipProtocol      = 15;
}

message MobileAuthInfo_O2C {
    required string                 requestId       = 1;
    required uint32                 type            = 2;       // 1: radius; 2: ldap
    required string                 userName        = 3;
    required string                 password        = 4;
}

message MobileAuthResult_C2O {
    required string                 requestId       = 1;
    required bool                   success         = 2;
    optional string                 message         = 3;
    repeated AuthResultAttribute    attributes      = 4;
    optional string                 dn              = 5;
}

message LdapSyncOU_O2C {
    required string                 ldapConfigId    = 1;
    required string                 baseDn          = 2;
}

message LdapSyncOUResult_C2O {
    required string                 ldapConfigId    = 1;
    required bool                   success         = 2;
    required string                 baseDn          = 3;
    optional string                 message         = 4;
    repeated string                 ouDns           = 5;
}

message LdapCheckAuth_O2C {
    required string                 requestId       = 1;
}

message LdapCheckAuthResult {
    required string                 server          = 1;
    required bool                   success         = 2;
    optional uint32                 errorCode       = 3;
    optional string                 message         = 4;
}

message LdapCheckAuth_C2O {
    required string                 requestId       = 1;
    repeated LdapCheckAuthResult    result          = 2;
}


// Definition for an LDAP attribute
message LdapAttribute {
    required string                 name            = 1;
    required string                 value           = 2;
}

message LdapSyncReqUserInfo {
    required string                 userDN          = 1;    // Note: The ldap options in the LDAP request align with settings in LdapConfig
    optional string                 password        = 2;    // Optional; set for authentication if needed
}

message LdapSyncReq_O2C {
    required string                 requestId       = 1;
    required uint32                 type            = 2;    // 1 for userInfo req
    repeated LdapSyncReqUserInfo    userInfo        = 3;
}

message LdapSyncReplyUserInfo {
    required uint32                 errNum          = 1;    // 0 for success, else refer to LW_LDAP_RELAY_AUTH_ERROR_CODE
    required string                 userDN          = 2;
    repeated LdapAttribute          attributes      = 3;
}

message LdapSyncReply_C2O {
    required string                 requestId       = 1;
    required uint32                 type            = 2;    // 1 for userInfo req
    optional uint32                 errNum          = 3;    // 0 for success, else indicate all request were not proceed propoly, LdapSyncReplyXXX might be null
    repeated LdapSyncReplyUserInfo  userInfo        = 4;
}

message CsvrChangeNotify_O2C {
    repeated CsvrAddr               csvrList        = 1;
    required bool                   switch          = 2;
}

message AuthResultAttribute {
    required string                 name            = 1;
    required string                 value           = 2;
}

// configure begin
message Configure_O2C {
    repeated BaseConfigure_O2C      tasks           = 1;
}

message ConfigureReply_C2O {
    repeated uint32                 results         = 1;
}

message WanUseDefaultShaperReport_C2O {
    required uint32                 wanId           = 1;
}

// zhangyang
message BaseConfigure_O2C {
    required uint32                 category        = 1;
    required uint32                 method          = 2;        // LW_METHOD

    repeated InterfaceItem          interface       = 101;      // chenxu & lipeng
    optional LanItem                lan             = 102;      // chenxu & lipeng
    repeated WanItem                wan             = 103;      // chenxu & lipeng
    repeated LinkIpTableItem        linkIpTable     = 104;      // chenxu & zhangyang
    repeated LinkItem               link            = 105;      // chenxu & zhangyang
    repeated TunnelRttItem          tunnelRtt       = 106;      // chenxu & zhangyang
    repeated EngineItem             engine          = 107 [deprecated=true];      // chenxu & yanghong
    optional DupConnItem            dupConn         = 108;      // chenxu & shengbo
    optional PathChange             pathChanged     = 109;      // chenxu & zhenli
    optional LogFileConf            logFileConf     = 110;
    optional SnatItem               snat            = 111;      // keyao  & zhenli
    optional DnatItem               dnat            = 112;      // keyao  & zhenli
    optional PolicyItem             policy          = 113;      // keyao  & yunpeng
    optional RateLimitItem          ratelimit       = 114;      // keyao  & yunpeng   2.x version message
    repeated AccessUnitItem         accessname      = 115;      // chenxu & yunpeng
    repeated DnsProxyItem           dnsProxy        = 116;      // keyao  & zhenli
    optional SshProxyItem           sshProxy        = 117;      // chenxu & yunpeng
    optional AccessAuditItem        accessAudit     = 118;      // chenxu & jackie
    repeated ProbeObject            probeObject     = 119;      // chenxu & zhangyang
    optional DistributeRatelimit    distributeRatelimit = 120;  // chenxu & yunpeng   3.x version distribute ratelimit message
    optional WifiItem               wifi            = 121;      // chenxu & lipeng
    optional DhcpItem               dhcp            = 122;      // chenxu & lipeng
    optional bool                   haEnable        = 123;      // chenxu & lipeng
    optional HeartbeatInfo          heartbeatInfo   = 124;      // chenxu & yanghong
    repeated ArpBindItem            arpBind         = 125;      // chenxu & lipeng
    optional HAConfig               haConfig        = 126;      // chenxu & lipeng
    optional RateLimitReportConf    ratelimitReportConf = 127;  // chenxu & yupeng    3.x version distribute ratelimit configuration
    optional ProbeServer            probeServerConf = 128;      // chenxu & yanghong  Only for POP which is used for probe server
    optional ClusterManager         clusterManager  = 129;

    optional BgpConfigure           bgpConfigure    = 131;      // xiaoyun & yunpeng
    optional CpeUnreachableInfo     cpeUnreachableInfo = 133;   // xiaoyun & yunpeng
    optional OspfConfigure          ospfConfigure   = 134;      // xiaoyun & yunpeng
    optional PublishedAUList        publishedAUList = 135;      // xiaoyun & yunpeng
    optional NatSwitchItem          natSwitch       = 136;      // chenxu & zhangyang
    optional DnsPolicyItem          dnsPolicy       = 137;      // chenxu & yunpeng
    optional ConnGlobalConfig       connGlobalConf  = 138;
    optional RouteVersionSynConfig  routeVersionSynConfig = 139;// xiaoyun & yunpeng
    optional MobileTrafficObject    mobileTrafficObject = 140;  // chenxu & yuheng
    optional EnableVPN              enableVPN       = 141;      // chenxu & yuheng
    optional DnsmasqConf            dnsmasqConf     = 142;      // chenxu & yunpeng
    optional PopDnsmasqConf         popDnsmasqConf  = 143;      // chenxu & zhenli
    optional FlowReportConfigure    flowReportConfigure = 144;  // chenxu & shengbo
    optional PopDCpeInfoItem        popDCpeInfo     = 145;      // jackie & taojing
    optional PopDCpeSupport         popDCpeSupport  = 146;      // jackie & taojing
    optional OutgoingInfCfg         outgoingInfCfg  = 148;      // chenxu & vincent
    optional AcceServerStatCfg      acceServStatsCfg= 149;      // chenxu & yuheng
    optional DomainAuditItem        domainAuditCfg  = 150;
    optional IpsecConfig            ipsecConfig     = 151;
    repeated IpsecConnectionConfig  ipsecConnectionConfig   = 152;
    optional TermReportConf         termReportConf  = 153;
    optional VirtualSwitchConfig    virtualSwitch   = 154;      // taojing & weijie
    optional LanTemplate            lanTemplate     = 155;      // taojing & weijie
    optional DeviceGlobalConf       devGlobalConf   = 156;      // chenxu & weijie
    repeated Shaper                 shaper          = 157;      // chenxu & weijie
    optional RadiusConfig           radiusConfigure = 158;      // kunkun & ziwei
    optional LdapConfig             ldapConfigure   = 159;      // kunkun & ziwei
    repeated MacFilterConfig        macFilter       = 160;      // taojing & weijie
    optional NatAuditItem           natAuditCfg     = 161;
    optional WanGatewayPool         wanGwPool       = 162;
    optional EngineParam            engineParam     = 163;
    optional Ospf6Configure         ospf6Configure  = 164;      // xiaoyun & yunpeng
    repeated InterfaceItemV2        interfaceItemV2 = 165;
    optional DhcpItemV2             dhcpItemV2      = 166;
    optional RouteSyncInterval      routeSyncInterval = 167;
    optional VpnConf                vpnConf         = 168;
    optional NtpConf                ntpConf         = 169;
    optional ServiceProxyConf       serviceProxyConf = 170;
    optional ValidatedIpItem        validatedIpItem = 171;
    optional VirtualSwitchVlanConf  virtualSwitchVlanConf = 172;
    repeated BgpNeighbor            bgpNeighbor     = 173;
    repeated WanSetSubInterface     wanSetSubInterface = 174;
    optional EngineConfigure        engineConfigure = 175 [deprecated=true];
    optional DatapathParam          datapathParam   = 176;
    optional IpMacFilterConfig      ipMacFilter     = 177;
    optional EmbedDevIntranetMode   embeddedDeviceIntranetMode = 178;
    optional LoopBackIntervalConfig loopBackIntervalConfig = 179;
    repeated LoopBackProbe          LoopBackProbe = 180;
    repeated SecurityInstance       securityInstance = 181;
    optional FlowAuditConf          flowAuditConf   = 182;
    optional AtkConf                atkConf         = 183;
    optional BlockListConf          blockListConf   = 184;
    optional IpsConf                ipsConf         = 185;
    optional IpsSignatureUpgradeConf ipsSignatureUpgradeConf = 186;
    optional SignatureUrl           signatureUrl    = 187;
    optional AvConf                 avConf          = 188;
    optional AvSignatureUpgradeConf avSignatureUpgradeConf = 189;
    optional SystemConf             systemConf      = 190;
    optional PolicyProbeConf        policyProbeConf = 191;
    optional DomainConf             domainConf      = 192;
    optional HardwareBypassConf     hardwareBypassConf = 193;
    optional WanStaticRouteConf     wanStaticRouteConf  = 194;
}

message DomainConf {
    optional string                 domainName      = 1;
}

message ComwareCloudConfig {
    required string                 domain          = 1;   //string length 1-253
    optional uint32                 port            = 2;   //range 1-65535
    optional string                 password        = 3;   //string length 1-63
}

message PolicyProbeConf {
    optional uint32                 probeInterval   = 1;
}

message FlowAuditConf {
    required bool                   enableNecessary = 1;
    required bool                   enableNormal    = 2;
}

message EmbedDevIntranetMode {
    required uint32                 id              = 1;        // identifier of this config
    required bool                   enable          = 2;
}

message BlockListConf {
    repeated BlockListItem          blockListItem = 1;
}

message BlockListItem {
    optional IpType                 srcip = 1;
    optional uint32                 timeout = 2;
    optional uint32                 vpnId = 3;
}

message AtkConf {
    repeated AtkItem                atkItem         = 1;
    repeated Ipset                  exceptIpset     = 2;
}

message AtkItem {
    required string                 id               = 1;
    required string                 name             = 2;
    optional string                 exceptIpsetId    = 3;
    optional AtkScanConf            atkScanConf      = 4;
    repeated AtkFloodConf           atkFloodConf     = 5;
    repeated AtkSignatureConf       atkSignatureConf = 6;
    optional uint64                 version          = 7;
}

message Ipset {
    required string                 id                = 1;
    optional string                 name              = 2;
    optional uint64                 version           = 3;
    repeated IpType                 ipList            = 4;
    repeated Ipv6Type               ipv6List          = 5;
    optional string                 url               = 6;
    optional uint32                 ipNum             = 7;
    optional uint32                 ipv6Num           = 8;
    optional bool                   persistentFlag    = 9;
    optional bool                   historyPersistent = 10;
}

message AtkScanConf {
    required uint32                 level           = 1;
    optional UserDefinedCfg         userDefinedCfg  = 2;
    required bool                   log             = 3;
    required bool                   drop            = 4;
    required BlockSource            blockSource     = 5;
}

message UserDefinedCfg {
    required bool                   portScanEnable  = 1;
    optional uint32                 portScanThreshold = 2;
    required bool                   ipSweepEnable   = 3;
    optional uint32                 ipSweepThreshold = 4;
    required uint32                 period          = 5;
}

message BlockSource {
    required bool                   enable          = 1;
    required uint32                 blockTime       = 2;
}

message AtkFloodConf {
    required uint32                 mainType        = 1;
    required uint32                 subType         = 2;
    required bool                   log             = 3;
    required bool                   drop            = 4;
    optional uint32                 threshold       = 5;
    optional uint32                 sourceThreshold = 6;
    optional string                 monitorPort     = 7;
    required bool                   enableStatus    = 8;
    optional AtkHttpSlowDefaultConf atkHttpSlowDefaultConf = 9;
}

message AtkHttpSlowDefaultConf {
    required uint32                 alertSessionNum = 1;
    required uint32                 contentLength   = 2;
    required uint32                 payloadLength   = 3;
    required uint32                 packetNumber    = 4;
    required uint32                 period          = 5;
    required BlockSource            blockSource     = 6;
}

message AtkSignatureConf {
    required uint32                 mainType        = 1;
    required uint32                 subType         = 2;
    required bool                   log             = 3;
    required bool                   drop            = 4;
    required bool                   enableStatus    = 5;
    optional AtkSignatureLargeICMPLengthConf atkSignatureLargeICMPLengthConf = 6;
}

message AtkSignatureLargeICMPLengthConf {
    optional uint32                 ipv4Threshold   = 1;
    optional uint32                 ipv6Threshold   = 2;
}

message IpsConf {
    repeated IpsItem                ipsItem         = 1;
}

message IpsItem {
    required string                 id              = 1;
    required string                 name            = 2;
    required IpsPolicyConf          ipsPolicyConf   = 3;
    repeated IpsPolicyExceptionSigsConf     ipsPolicyExceptionSigsConf = 4;
    optional uint64                 version         = 5;
}

message ProtectionList {
    required uint32                 protectionId    = 1;        /*ID of the protected target*/
    required uint32                 subProtectionId = 2;
}

message CategoryList {
    required uint32                 categoryId      = 1;        /*ID of the attack category*/
    required uint32                 subCategoryId   = 2;
}

message IpsPolicyConf {
    required uint32                 filterDirection = 1;        /*Traffic direction to which the IPS signature applies*/
    required uint32                 filterSeverity  = 2;        /*Severity level of the IPS signature*/
    required uint32                 filterAction    = 3;        /*Default action of the IPS signature*/
    repeated ProtectionList         protectionList  = 4;
    repeated CategoryList           categoryList    = 5;
}

message IpsPolicyExceptionSigsConf {
    required uint32                 sigID           = 1;        /*ID of the IPS signature*/
    required bool                   enabled         = 2;        /*Whether or not the IPS signature is enabled*/
    required uint32                 action          = 3;        /*Flood threshold based on destination IP*/
    required bool                   logging         = 4;        /*Whether or not to log the matching packets*/
}

message IpsSignatureUpgradeConf {
    required bool                   ipsSignatureUpgradeNowConf = 1;
    optional IpsSignatureAutoUpgradeConf   ipsSignatureAutoUpgradeConf = 2;
    optional string                 signatureVersion = 3;
}

message IpsSignatureAutoUpgradeConf {
    required bool                   enabled         = 1;        /*Whether or not IPS signature library autoupdate is enabled*/
    optional string                 startTime       = 2;        /*Time when IPS signature library auto updatestarts*/
    optional uint32                 type            = 3;        /*Whether IPS signature libraryauto update occurs on a daily or a weekly basis*/
    optional uint32                 day             = 4;        /*Days of the weekon which IPS signature library auto update occurs*/
}

message SignatureUrl{
    required string                 url             = 1;
}

message AvConf {
    repeated AvItem                avItem           = 1;
}

message AvItem {
    required string                 id              = 1;
    required string                 name            = 2;
    optional uint64                 version         = 3;
    repeated AvProto                proto           = 4;
    repeated string                 exceptionMd5    = 5;
}

message AvProto {
    required uint32                 direction       = 1;
    required uint32                 action          = 2;
}

message AvSignatureUpgradeConf {
    required bool                   avSignatureUpgradeNowConf = 1;
    optional AvSignatureAutoUpgradeConf   avSignatureAutoUpgradeConf = 2;
    optional string                 signatureVersion = 3;
}

message AvSignatureAutoUpgradeConf {
    required bool                   enabled         = 1;
    optional string                 startTime       = 2;
    optional uint32                 type            = 3;
    optional uint32                 day             = 4;
}

message LogFileConf {
    required uint32                 maxSize         = 1;
    required uint32                 fileNum         = 2;
}

message RouteSyncInterval {
    required uint32                 interval        = 1;        // Route version sync (message 439) interval, default 120s
}

message NtpServer {
    required uint32                 type            = 1;        // 0:domain 1:netaddr
    optional string                 domain          = 2;
    optional NetAddr                addr            = 3;
}

message NtpConf {
    repeated NtpServer              ntpServer       = 1;
}

message VpnConfItem {
    required uint32                 vpnType           = 1;        // LW_ORCH_VPN_TYPE
    required uint32                 vpnId             = 2;
    optional uint32                 customerId        = 3;
    optional uint32                 cpeId             = 4;
    optional bool                   withoutNamespace  = 5;
    optional bool                   disableDynRouting = 6;
}

message VpnConf {
    repeated VpnConfItem            vpnItem         = 1;
}

message EngineConf {
    required uint32                 type            = 1;        // LW_ENGINE_PARAM_TYPE
    repeated uint32                 value           = 2;
}

message EngineParam {
    repeated EngineConf             engineConfs      = 1;
}

message DatapathConf {
    required uint32                 type            = 1;
    optional uint32                 singleU32Value  = 2;
    optional uint64                 singleU64Value  = 3;
    repeated uint32                 multiU32Value   = 4;
    optional bytes                  ipv6            = 5;
}

message DatapathParam {
    repeated DatapathConf           datapathConf    = 1;
}

message WanGwItem {
    required uint32                 wanId           = 1;
    required string                 ifname          = 2;
    repeated NetAddr                gwAddrs         = 3;
}

message WanGatewayPool {
    required bool                   enable          = 1;
    repeated WanGwItem              wanGwItem       = 2;
}

message ClusterManager {
    required bool                   clusterEnable   = 1;
    optional uint32                 role            = 2;        // LW_CLUSTER_ROLE
    optional uint32                 masterCpeIp     = 3;
    optional uint32                 masterCpePort   = 4;
    optional uint32                 calenderQueueLen= 5;        // For distribute shaping
    optional uint32                 masterCpeId     = 6;
    optional uint32                 localLanId      = 7;
    optional uint32                 localPort       = 8;
    repeated uint32                 slaveCpeIdList  = 9;
    optional uint32                 detectInterval  = 10;       // ms
}

message ClusterStatusReport_C2O {
    required uint32                 lanPacketNum    = 1;
    required uint32                 role            = 2;       // 1:manager 2:slave
    repeated ClusterMemberStatus    memberStatus    = 3;
}

message ClusterMemberStatus {
    required uint32                 cpeId           = 1;
    required uint32                 status          = 2;       // 0:loss  1:normal
}

message ClusterManagerReport_C2O {
    required uint32                 slaveCpeId      = 1;
    required uint32                 masterCpeId     = 2;
    optional string                 message         = 3;
}

message NatAuditReport_C2O {
    repeated NatAuditStats          natAuditStats   = 1;
}

message NatAuditStats {
    required uint32                 natType         = 1;        //0:snat 1:dnat 2:dualNat
    required uint32                 inPortType      = 2;        //1:lan 2:wan 3:Conn C2C 4:Conn C2P
    required uint32                 inPortId        = 3;        //LanId/WanId or LightWAN Connection ID according to inPortType
    required uint32                 outPortType     = 4;
    required uint32                 outPortId       = 5;
    required NetAddr                originalSrcIP   = 6;
    required uint32                 originalSrcPort = 7;
    required NetAddr                originalDstIP   = 8;
    required uint32                 originalDstPort = 9;
    required NetAddr                currentSrcIP    = 10;
    required uint32                 currentSrcPort  = 11;
    required NetAddr                currentDstIP    = 12;
    required uint32                 currentDstPort  = 13;
    required uint32                 ipProtocol      = 14;       // IP protocol(tcp/udp/etc.)
    required uint64                 accessTime      = 15;       // Timestamp
    optional bool                   relatedFlag     = 16;
}

message NetAddr {
    required uint32                 addrType        = 1;        //1:ipv4 2:ipv6
    optional uint32                 ipv4            = 2;
    optional bytes                  ipv6            = 3;
}

message IpAddr {
    optional uint32                 ipv4            = 1;
    optional bytes                  ipv6            = 2;
}

message DeviceGlobalConf {
    optional uint32                 lttMaxNum       = 1;
    optional uint32                 shrinkPktConf   = 2;        // 0:auto 1:on 2:off
    optional bool                   l2OnlyTransit   = 3;        // true:on false:off
    optional uint32                 flowHashBits    = 4;
    optional uint32                 pmtuTimeoutMs   = 5;
    optional uint32                 lttRecoverTimeout = 6;
    optional uint32                 packetPoolSize    = 7;
    optional uint32                 lttPacketPoolSize = 8;
}

message TermReportConf {
    optional bool                   triggerTermInfoReport = 1;  // trigger terminal app report device info
}

message AcceSrvStatsCfgItem {
    required uint32                 serverIp        = 1;        // acce server ip
    repeated string                 oid             = 2;        // eg. ".1.3.6.1.4.1.32479.3.11~X.2~Y" X means province Y means city
    required string                 community       = 3;        // current yunshixun community string is "mTYhaT3s"
    optional bytes                  serverIpv6      = 4;
}

//Only for yunshixun Pop
message AcceServerStatCfg {
    required bool                   enable          = 1;        // enable acce server stats report or not
    repeated uint32                 serverIps       = 2;        // acce server ip, it will be multiple
    repeated string                 oid             = 3;        // eg. ".1.3.6.1.4.1.32479.3.11~X.2~Y" X means province Y means city
    optional string                 community       = 4;        // current yunshixun community string is "mTYhaT3s"
    repeated AcceSrvStatsCfgItem    acceSrvStatsCfgItem = 5;
    repeated bytes                  serverIpv6s     = 6;
}

message AcceStats {
    required string                 oid             = 1;
    required uint64                 southUpBytes    = 2;
    required uint64                 southDownBytes  = 3;
    required uint64                 northUpBytes    = 4;
    required uint64                 northDownBytes  = 5;
}

message AcceServStatsItem {
    required uint32                 serverIp        = 1;
    repeated AcceStats              oneServerStats  = 2;
    optional bytes                  serverIpv6      = 3;
}

message AcceServStatReport_C2O {
    repeated AcceServStatsItem      acceServStatItem= 1;        // Each acce server stats
    optional uint32                 timestamp       = 2;        // second
}

message PopDnsmasqConf {  //Only for Pop
    required bool                   enable          = 1;
    repeated uint32                 dns             = 2;
    required uint32                 localIp         = 3;
    optional bool                   persistentFlag  = 4;
    optional bool                   historyPersistent = 5;      // If the conf is persistent in history
    repeated bytes                  dnsIpv6         = 6;
    optional bytes                  localIpv6       = 7;
}

message DupConnItem {
    repeated TunnelRttItem          oneOfDupConn    = 1;        // one of the dup connection. The the number of dupConn must be 2
}

message ProbeServer {
    required bool                   enable          = 1;
    repeated Range                  dataPortRange   = 2;        // data port range by orch
}

message ConnGlobalConfig {
    required uint32                 maxDelayBottom  = 1;        // ms
}

message TrackIntfItem{
    required string                 ifname          = 1;
    required uint32                 weight          = 2;
    optional uint32                 bindLayer2LanId = 3;
    optional uint32                 vpnId           = 4;
}
message DistributeRatelimit {
    required uint32                 id              = 1;
    optional uint32                 bandwidth       = 2;         //rate_limit_table BucketRate
    optional uint64                 commitBurstSize = 3;         //rate_limit_table CBS
    optional uint32                 ratelimitApplyType = 4;      // 0: default, apply on all traffic; 1: apply on per src ip; 2: apply on per dst ip;
    optional uint32                 perIpBandwidth  = 5;
    optional uint64                 perIpCommitBurstSize = 6;
    optional bool                   persistentFlag  = 7;
    optional bool                   historyPersistent = 8;       // If the conf is persistent in history
    optional uint32                 customerId      = 9;
    optional uint32                 rateLimitObjId  = 10;
    optional PerIpRatelimit         perSrcIpRatelimit = 11;
    optional PerIpRatelimit         perDstIpRatelimit = 12;
}

message PerIpRatelimit {
    required uint32                 bandwidth       = 1;
    required uint64                 commitBurstSize = 2;
}

message RateLimitReportConf {
    required uint32                 reportInterval  = 1;         //ratelimit stats report interval
}

message VipItem {
    required string                 ifName          = 1;
    repeated Cidr                   ip              = 2;         //must has one ip at least
    repeated Ipv6Cidr               ipv6            = 3;
    optional uint32                 vpnId           = 4;
}

message TrackScriptItem {
    required uint32                 type            = 1;         //LW_HA_TRACK_TOOL
    required string                 ifName          = 2;
    required uint32                 dstIp           = 3;
    required uint32                 pktNum          = 4;
    required uint32                 weight          = 5;
    optional bytes                  dstIpv6         = 6;
    optional uint32                 vpnId           = 7;
}

message UnicastItem {
    required string                 ifname          = 1;
    required uint32                 masterIp        = 2;
    required uint32                 slaveIp         = 3;
    optional bytes                  masterIpv6      = 4;
    optional bytes                  slaveIpv6       = 5;
}

message HAConfig{
    required bool                   haEnable        = 1;
    repeated string                 haInterface     = 2;
    optional bool                   isPreemptMode   = 3;         //required, default is preempt mode. true : preempt mode, false : noPreempt mode; MUST has preempt delay and priority.
    optional uint32                 PreemptDelay    = 4;         //required, second, for preempt mode, default is 30s, for no_preempt mode, default is 0s
    optional uint32                 masterPriority  = 5;         //required, for preempt mode, default is 251, for no_preempt mode, default is 200
    optional uint32                 slavePriority   = 6;         //required, default is 200
    repeated TrackIntfItem          trackIntfItem   = 7;
    repeated VipItem                vips            = 8;
    repeated TrackScriptItem        trackScriptItem = 9;
    repeated UnicastItem            unicastItem     = 10;
}

message HeartbeatInfo {
    optional uint32                 timeInterval    = 1;
    optional uint32                 timeoutTimes    = 2;
}

// lan/wan/interface/wifi/dhcp, chenxu & lipeng
message InterfaceItem {
    required string                 ifname          = 1;
    required uint32                 type            = 2;        // LW_INTERFACE_TYPE
    optional InterfaceLayer2        layer2          = 3;
    required InterfaceLayer3        layer3          = 4;
    optional BridgeParam            bridge          = 5;
    optional VLanParam              vlan            = 6;
    optional BondingParam           bonding         = 7;
    repeated InterfaceLayer3        haDevicesLayer3 = 8;      // Layer3 config for multi-devices sharing same cpe id in ha mode, index 0 for master device and 1 for slave device; More than two device can be extended in this structure in the furture
    optional uint32                 vpnId           = 9;
    optional bool                   multiApnEnable  = 10;

}

message PPPOEConf {
    required string                 pppoeUsername   = 1;
    required string                 pppoePassword   = 2;
    optional uint32                 pppoeDialMode   = 3;       // 0: Multi Dial 1: Single Dial
    optional uint32                 pppoeReconnectInterval = 4;// second.
    optional uint32                 pppoeLcpEchoRequestInterval = 5 [deprecated=true]; //pppoe send lcp echo request interval ,the default interval is ten seconds
    optional uint32                 pppoeLcpEchoRequestFailure = 6 [deprecated=true]; //pppoe send lcp cho request failureï¼Œno reply will be received twice by default
    optional bool                   pppoeMonitorEnable = 7 [deprecated=true];    // enable pppoe monitor ping ip , 1: enable, 0: disable
    repeated uint32                 pppoeMonitorIp  = 8 [deprecated=true];       // pppoe monitor ping ip address
    optional uint32                 icmpPktLen      = 9 [deprecated=true];       // pppoe monitor ping ip packet length, range[46,1200]
}

message LteConf {
    required bool                   lteEnable       = 1;        // deprecated
    optional string                 carrier         = 2;        // deprecated
    optional string                 pppInf          = 3;        // deprecated
    optional string                 dialNumber      = 4;        // deprecated
    optional string                 apn             = 5;        // deprecated
    optional SinglePdnParam         singlePdn       = 6;        // single pdn dialing for 4G/5G
    optional MultiPdnParam          multiPdn        = 7;        // multiple pdn dialing for 4G/5G
}

message SinglePdnParam {
    required bool                   enable          = 1;
    optional string                 apn             = 2;
}

message MultiPdnParam {
    required bool                   enable          = 1;
    optional string                 apn             = 2;
    required uint32                 index           = 3;        // range[1,6]
}

message MultiApnConf {
    required bool                   enable          = 1;
    optional uint32                 wwanSlotId      = 2;
}

message WWanConf {
    required bool                   enable          = 1;
    optional string                 apn             = 2;
    optional uint32                 index           = 3;  // required when using multi-apn config
    optional uint32                 wwanSlotId      = 4;
}

message InterfaceRealIP {
    repeated Cidr                   ipv4Addr        = 1;
    repeated Ipv6Cidr               ipv6Addr        = 2;
}

message InterfaceLayer3V2 {
    required uint32                 addrType        = 1;        //LW_NET_ADDR_TYPE
    required uint32                 proto           = 2;        // LW_INTERFACE_PROTO
    repeated Cidr                   ipv4Addr        = 3;
    repeated Ipv6Cidr               ipv6Addr        = 4;
    repeated InterfaceRealIP        RealIpGroup     = 5;        //Only for HA mode, index 0 for master cpe, 1 for slave cpe
    optional PPPOEConf              pppoeConf       = 6;
    optional LteConf                lteConf         = 7;
    optional MultiApnConf           multiApnConf    = 8;        // deprecated
    optional WWanConf               wwanConf        = 9;        // deprecated
    optional uint32                 gatewayIp       = 10;       //Only for vlan interface of wan with multiple subinterface
    optional bytes                  ipv6GatewayIp   = 11;       //Only for vlan interface of wan with multiple subinterface
}

message InterfaceItemV2 {
    required string                 ifname          = 1;
    required uint32                 type            = 2;        // LW_INTERFACE_TYPE
    optional InterfaceLayer2        layer2          = 3;
    repeated InterfaceLayer3V2      layer3          = 4;
    optional BridgeParam            bridge          = 5;
    optional VLanParam              vlan            = 6;
    optional BondingParam           bonding         = 7;
    optional uint32                 vpnId           = 8;
    optional GreTunnelParam         gre             = 9;
}

message InterfaceLayer2 {
    required bool                   autoNeg         = 1;
    required string                 mac             = 2;
    optional uint32                 mtu             = 3;
    required bool                   arpProxy        = 4;        // if arpProxy is TRUE, ipForward MUST be TRUE.
    optional uint32                 speed           = 5;
    optional bool                   duplex          = 6;
    optional bool                   ipForward       = 7;
    optional bool                   rxChecksumOff   = 8;        // true:rx-checksum=off false:rx-checksum=on
}

message InterfaceLayer3 {
    required uint32                 proto           = 1;        // LW_INTERFACE_PROTO
    repeated Cidr                   addrs           = 2;
    optional string                 pppoeUsername   = 4;
    optional string                 pppoePassword   = 5;
    optional bool                   lteEnable       = 6;
    optional string                 carrier         = 7;
    optional string                 pppInf          = 8;
    optional string                 dialNumber      = 9;
    optional string                 apn             = 10;
    repeated Ipv6Cidr               ipv6Addrs       = 11;
    optional uint32                 pppoeDialMode   = 12;       // 0: Multi Dial 1: Single Dial
    optional uint32                 pppoeReconnectInterval = 13;// second.
    optional uint32                 pppoeLcpEchoRequestInterval = 14 [deprecated=true];  //pppoe send lcp echo request interval ,the default interval is ten seconds
    optional uint32                 pppoeLcpEchoRequestFailure = 15 [deprecated=true]; //pppoe send lcp echo request failureï¼Œno reply will be received twice by default
    optional bool                   pppoeMonitorEnable = 16 [deprecated=true];    // enable pppoe monitor ping ip, 1: enable, 0: disable
    repeated uint32                 pppoeMonitorIp  = 17 [deprecated=true];       // pppoe monitor ping ip address
    optional uint32                 icmpPktLen      = 18 [deprecated=true];       // pppoe monitor ping ip packet length, range[46,1200]
    optional uint32                 wwanSlotId      = 19;
    optional uint32                 wwanIndex       = 20; // required when using multi-apn config
    optional Cidr                   masterIp        = 21;       // used only for wan with multiple interfaces
    optional uint32                 gatewayIp       = 22;       // used only for wan with multiple interfaces
    optional Ipv6Cidr               ipv6MasterIp    = 23;       // used only for wan with multiple interfaces
    optional bytes                  ipv6GatewayIp   = 24;       // used only for wan with multiple interfaces
}

message BridgeParam {
    repeated string                 ifnames         = 1;  //has two interfaces such as eth1,eth2
    required string                 lanIfname       = 2;  //Specify which interface is LAN such as eth1
    optional bool                   enableBypass    = 3;  // bridge support bypass , not switch to bypass status at once !!
    optional uint32                 type            = 4;  // bridge type, 0: LAN-WAN Bridge, 1: LAN Bridge, default value is 0
    repeated string                 lanInterfaces   = 5;  // one or more lan interfaces. @used by new CPE
    repeated string                 wanInterfaces   = 6;  // one or more wan interfaces. @used by new CPE
}

message BondingParam {
    required uint32                 mode            = 1;  // bonding mode: balance-rr(0), active-backup(1), balance-xor(2), broadcast(3), 802.3ad(4), balance-tlb(5), balance-alb(6)
    repeated string                 subInterfaces   = 2;  // two or more sub interfaces of the same type
}

message GreTunnelItem {
    optional uint32                 localIp         = 1;
    optional uint32                 remoteIp        = 2;
}

message GreTunnelV6Item {
    optional bytes                  localIp         = 1;
    optional bytes                  remoteIp        = 2;
}

message GreTunnelParam {
    required string                 mainIfname      = 1;
    required uint32                 type            = 2;  // LW_GRE_TUNNEL_TYPE
    optional GreTunnelItem          greTunnel       = 3;
    optional GreTunnelV6Item        greTunnelV6     = 4;
}

message WifiItem {
    required bool                   enable          = 1;
    optional WifiParam              param           = 2;
    optional uint32                 wifiType        = 3;        //LW_WIFI_TYPE
}

message WifiParam {
    required string                 ssid            = 1;
    required uint32                 channel         = 2;
    required uint32                 encryption      = 3;
    optional string                 password        = 4;
    optional string                 ifname          = 5;
    repeated uint32                 proto           = 6;        // LW_WIFI_PROTO
    repeated uint32                 bandwidth       = 7;  // 20: 20Mhz; 40: 40Mhz; 80: 80Mhz
}

message Ipv4DhcpServer {
    repeated Range                  dhcpIpRange     = 1;
    required uint32                 netmask         = 2;
    repeated uint32                 dns             = 3;
    optional uint32                 offerTime       = 4;
    optional uint32                 gateway         = 5;
    required uint32                 leaseTime       = 6;
}

message Ipv4DhcpRelay {
    repeated uint32                 relayServer     = 1;
    required uint32                 lanIp           = 2;
}

message Ipv4DhcpItem {
    required uint32                 mode            = 1;        // LW_DHCP_MODE
    optional Ipv4DhcpServer         dhcpServer      = 2;
    optional Ipv4DhcpRelay          dhcpRelay       = 3;
}

message Ipv6DhcpServer {
    repeated Ipv6Range              dhcpIpRange     = 1;
    optional uint32                 prefixLength    = 2;
    repeated bytes                  dns             = 3;
    optional uint32                 offerTime       = 4;
    optional uint32                 leaseTime       = 5;
    optional bytes                  prefix          = 6;
    optional uint32                 ipv6DynamicMode = 7;        // LW_DYNAMIC_MODE
    optional uint32                 dnsDynamicMode  = 8;        // LW_DYNAMIC_MODE
}

message Ipv6DhcpRelay {
    repeated bytes                 relayServer     = 1;
    required bytes                 lanIp           = 2;
}

message Ipv6DhcpItem {
    required uint32                 mode            = 1;        // LW_DHCP_MODE
    optional Ipv6DhcpServer         dhcpServer      = 2;
    optional Ipv6DhcpRelay          dhcpRelay       = 3;
}

message DhcpItemV2 {
    required string                 ifname          = 1;
    optional Ipv4DhcpItem           ipv4DhcpItem    = 2;
    optional Ipv6DhcpItem           ipv6DhcpItem    = 3;
}

message DhcpItem {
    required uint32                 mode            = 1;        // LW_DHCP_MODE
    optional DhcpServer             server          = 2;
    optional DhcpRelay              relay           = 3;
    optional string                 ifname          = 4;
    optional DhcpServerV2           dhcpServerV2    = 5;
}

message DhcpServer {
    required string                 ifname          = 1;
    required uint32                 dhcpStartIp     = 2;
    required uint32                 dhcpEndIp       = 3;
    required uint32                 netmask         = 4;
    optional uint32                 dns             = 5;
    optional uint32                 gateway         = 6;
    required uint32                 leaseTime       = 7;
    optional bytes                  dhcpStartIpv6   = 8;
    optional bytes                  dhcpEndIpv6     = 9;
    optional bytes                  ipv6Gateway     = 10 [deprecated=true];
    optional bytes                  ipv6Dns         = 11;
    optional uint32                 prefixLength    = 12;
    optional uint32                 ipv6LeaseTime   = 13;
}

message DhcpServerV2 {
    required string                 ifname          = 1;
    repeated Range                  dhcpIpRange     = 2;
    required uint32                 netmask         = 3;
    repeated uint32                 dns             = 4;
    optional uint32                 offerTime       = 5;
    optional uint32                 gateway         = 6;
    required uint32                 leaseTime       = 7;
    repeated Ipv6Range              dhcpIpv6Range   = 8;
    optional bytes                  ipv6Dns         = 9;
    optional uint32                 prefixLength    = 10;
    optional uint32                 ipv6LeaseTime   = 11;
    optional uint32                 ipv6OfferTime   = 12;
}

message DhcpRelay {
    repeated uint32                 relayServer     = 1;
    required uint32                 lanIp           = 2;
}

message Shaper {
    required uint32                 shaperId        = 1;       // shaperId = wan id
    required uint32                 wanKbps         = 2;       // default 1000000
    required uint32                 wanInKbps       = 3;       // default 1000000
    required uint32                 inBurstMs       = 4;       // default 4 max 65535
    required uint32                 outBurstMs      = 5;       // default 4 max 65535
    required uint32                 sharedPriority  = 6;
    repeated uint32                 bandwidthDist   = 7;       // bandwidth Dist number MUST be 8
    repeated BandwidthLimit         bandwidthLimit  = 8;
    required bool                   persistentFlag  = 9;
    required bool                   historyPersistent = 10;
    optional uint32                 sharedNum       = 11;      // How many acitve device to share this shaper. 1 for non-multi-dev shaping
    repeated BandwidthLimit         guaranteeBandwidth  = 12;   //#50618 bandwidth guarantees for priorities
}

message RadiusConfig {
    required bool                   enable           = 1;
    repeated string                 authServer       = 2;
    required string                 authOrder        = 3;
    required string                 dictionary       = 4;
    required uint32                 loginTries       = 5;
    required uint32                 loginTimeout     = 6;
    required uint32                 radiusTries      = 7;
    required uint32                 radiusTimeout    = 8;
    optional string                 defaultRealm     = 9;
}

message LdapConfig {
    required bool                   enable           = 1;
    repeated string                 authServer       = 2;       //uri:port e.g.1 LDAP over SSL ldaps://192.168.32.142:636 e.g.2 Standard: ldap://192.168.32.142:389
    required string                 baseDn           = 3;       //e.g OU=TEST,DC=aqstest,DC=com
    required string                 bindUser         = 4;
    required string                 bindPassword     = 5;
    required uint32                 timeout          = 6;       //second
    required uint32                 version          = 7;       //1: LDAP_VERSION2 2: LDAP_VERSION3
    optional string                 userAccountAttr  = 8;       //cn/sAMAccountName/userPrincipalName etc.
    optional string                 searchBaseDn     = 9;
    optional uint32                 searchScope      = 10;      //LW_AUTH_RELAY_LDAP_SEARCH_SCOPE
    optional string                 searchFilter     = 11;
}

message WanItem {
    required WanTable               wanTable        = 1;
    optional Qos                    qos             = 2;       // deprecated after the version contains Multi-shaper
    repeated uint32                 dns             = 3;
    optional bool                   persistentFlag  = 4;
    optional bool                   historyPersistent = 5;     // If the conf is persistent in history
    optional uint32                 shaperId        = 6;       // required after the version contains Multi-shaper
    optional uint32                 macFilterId     = 7;       // Id of mac filter config
    repeated bytes                  ipv6Dns         = 8;
    optional uint32                 vpnId           = 9;
}

message EngineItem {
    required uint32                 id              = 1;
    map<string, string>           params            = 2;
}

message WanTable {
    required uint32                 id              = 1;
    required string                 ifname          = 2;
    required uint32                 wanType         = 3;        // LW_WAN_TYPE
    optional Cidr                   masterIp        = 4;
    optional uint32                 gatewayIp       = 5;
    required bool                   orchConnection  = 6;
    required uint32                 priority        = 7;
    optional bool                   asDefaultRoute  = 8;
    optional bool                   enableBridgeProxy = 9;
    optional uint32                 bridgeProxyIp   = 10;
    optional uint32                 engineNum       = 11;       // deprecated after the version contains Multi-shaper
    optional bool                   enableBindMac   = 12;
    optional string                 gatewayMac      = 13;
    optional string                 proxyMac        = 14;
    optional bool                   defaultRouteType= 15;       // output is default route
    optional uint32                 bridgeProxyMask = 16;       // such as 24
    optional uint32                 bridgeIntfIp    = 17;
    optional uint32                 maxLttNum       = 18;       // replaced by SiteGlobalConf->lttMaxNum after the version contains Multi-shaper
    optional bool                   minUsage        = 19;
    optional bool                   exclusiveMode   = 20;
    repeated HAGatewayItem          haDevicesGws    = 21;       // Gateway config for multi-devices sharing same cpe id in ha mode, index 0 for master device and 1 for slave device; More than two device can be extended in this structure in the furture
    optional Ipv6Cidr               ipv6MasterIp    = 22;
    optional bytes                  ipv6GatewayIp   = 23;
    optional bytes                  ipv6BridgeIntfIp= 24;
    optional bytes                  ipv6BridgeProxyIp = 25;
    optional uint32                 ipv6BridgeProxyMask = 26;
    repeated HAIpv6GatewayItem      haDevicesIpv6Gws    = 27;   // Ipv6Gateway config for multi-devices sharing same cpe id in ha mode, index 0 for master device and 1 for slave device; More than two device can be extended in this structure in the furture
    optional bool                   backupFlag      = 28;
    optional bool                   multiSubInterface   = 29;   // 0: a wan has a interface, 1: a wan has multiple subinterfaces
    optional uint32                 mtuReserve      = 30;
}

message HAGatewayItem {
    required uint32                 gatewayIp       = 1;
}

message HAIpv6GatewayItem {
    required bytes                 gatewayIpv6       = 1;
}

message BandwidthLimit {
    required uint32                 priority        = 1;
    required uint32                 inKbps          = 2;
    required uint32                 outKbps         = 3;
}

message EngineBandwidthConf {
    repeated uint32                 bandwidthDist   = 1;        // bandwidth Dist number MUST be 8
    repeated BandwidthLimit         bandwidthLimit  = 2;
}

message Qos {
    required uint32                 wanKbps         = 1;
    required uint32                 wanInKbps       = 2;
    map<string, QosValue>           priorityBw      = 3;
    optional uint32                 sharedPriority  = 4;
    optional EngineBandwidthConf    engineBwConf    = 5;
}

message QosValue {
    repeated uint32                 qos_value       = 1;
}

message ValidatedIpItem {
    required uint32                 configType      = 1;        //1.Incremental  2.Full amount
    required uint32                 vpnId           = 2;
    required uint32                 lanId           = 3;
    required uint32                 addrType        = 4;        //1:ipv4 2:ipv6
    repeated uint32                 ipAddr          = 5;
    repeated bytes                  ipv6Addr        = 6;
}

message VirtualSwitchVlanConf {
    required uint32                 lanId           = 1;
    required uint32                 vswitchId       = 2;
    optional uint32                 pvid            = 3;
    repeated Range                  vlanList        = 4;
}

message LoopBackIntervalConfig {
    required uint32                 probeInterval       = 1;
    required uint32                 keepaliveInterval   = 2;
    required uint32                 recoverInterval     = 3;
}

message LoopBackProbe {
    required uint32                 lanId           = 1;
    repeated Range                  vlanList        = 2;
}

message LanRouteConf {
    required uint32                 addrType        = 1;        //1:ipv4 2:ipv6
    repeated IpType                 ipv4NetList     = 2;
    optional uint32                 ipv4NextHop     = 3;
    repeated Ipv6Type               ipv6NetList     = 4;
    optional bytes                  ipv6NextHop     = 5;
    optional uint32                 subnetType      = 6;        //1.trusted 2.undetermined
}

message LanItem {
    required uint32                 id              = 1;
    required string                 ifname          = 2;
    repeated IpType                 netlist         = 3;
    optional uint32                 nexthop         = 4;
    optional bool                   l2              = 5;
    optional bool                   persistentFlag  = 6;
    optional bool                   historyPersistent = 7;      // If the conf is persistent in history
    optional uint32                 vswitchId       = 8;        // 0: this LAN not belongs to a virtual switch; > 0: id of the virtual switch this LAN belongs to
    optional bool                   virtual         = 9;        // 0: physical lan; 1: virtual lan
    optional uint32                 macFilterId     = 10;       // Id of mac filter config
    repeated LanRouteConf           lanRouteConf    = 11;
    optional uint32                 vpnId           = 12;
}

message MacFilterConfig {                                       // defines access control of a list of mac addresses
    required uint32                 id              = 1;        // identifier of this config
    required uint32                 strategy        = 2;        // 0: white list(allow access of macs in the list); 1: black list(allow access of macs not in the list)
    repeated string                 macs            = 3;        // the list the mac addresses
    optional bool                   persistentFlag  = 4;        // if the conf is persistent
    optional bool                   historyPersistent = 5;      // if the conf is persistent in history
    optional uint32                 action          = 6;        // when the mac matches based on above strategy, do that action. 0: bypass datapath for the packet(default); 1: drop the packet
}

message NatAuditItem {
    required bool                   enable          = 1;
}

message IpMacFilterConfig {                                     // define a list of IP/MAC binding information of a list
    required bool                   ipMacEnable     = 1;        // control IP/MAC function switch
    required bool                   flowRestriction = 2;        // TRUE: Flow without bound IP/MAC addresses is not allowed to pass
    repeated ZoneIpMacFilterConfig  zoneIpMacFilter = 3;        // IP/MAC configuration under the security zone
    optional bool                   persistentFlag  = 4;        // if the conf is persistent
    optional bool                   historyPersistent = 5;      // if the conf is persistent in history
}

message ZoneIpMacFilterConfig {
    required uint32                 vpnId           = 1;        // identifier of Security domain
    repeated IpMacConfig            ipMacs          = 2;        // the list the mac addresses and ip addresses
}

message IpMacConfig {                                           // define a single IP/MAC message structure
    required string                 mac            = 1;         // mac  address
    required uint32                 ipType         = 2;         // mark whether the current rule uses IPv4 or IPv6
    optional IpType                 ipv4Addr       = 3;         // ipv4 address
    optional Ipv6Type               ipv6Addr       = 4;         // ipv6 address
}


message ArpBindItem {
    required string                 mac             = 1;
    required uint32                 ip              = 2;
    optional bytes                  ipv6            = 3 [deprecated=true];
    optional string                 ifname          = 4 [deprecated=true];
}

message LinkIpTableItem {
    required uint32                 customerId      = 1;        // cpe/pop
    required uint32                 clientId        = 2;        // cpeId/popId
    required uint32                 wanId           = 3;        // ipId
    optional uint32                 ip              = 4;
    optional bool                   persistentFlag  = 5;
    optional bool                   historyPersistent = 6;      // If the conf is persistent in history
    optional bytes                  ipv6            = 7;
    optional uint32                 vpnId           = 8;
}

// snat/dnat/policy, chenxu  & zhangyang,yunpeng
message BaseForward {
    required uint32                 id              = 1;
    required uint32                 preId           = 2;
    required bool                   dualFlag        = 3;
    required uint32                 zone            = 4;
    optional bool                   revalFlag       = 5 [default = true];
    optional bool                   persistentFlag  = 6;        // If the rule is persistent
    optional bool                   persistenceChanged= 7;      // If the persistence of rule has been changed
    optional bool                   incrementFlag   = 8;        // If the rule is Incremental configuration
    optional uint32                 prePersistId    = 9;        // Pre persistent policy id
    optional bool                   historyPersistent = 10;     // If the conf is persistent in history
    optional uint32                 vpnId           = 11;
    optional bool                   relatedFlag     = 12;
    optional uint32                 version         = 13;
}

message SnatItem {
    required BaseForward            forwardParams   = 1;
    required NatMatch               match           = 2;
    required SnatAction             action          = 3;
}

message DnatItem {
    required BaseForward            forwardParams   = 1;
    optional NatMatch               match           = 2;
    required DnatAction             action          = 3;
}

message NatSwitchItem {
    optional bool                  sipEnable    = 1 [default = false];
    optional bool                  h323Enable   = 2 [default = false];
    optional bool                  ftpEnable    = 3 [default = false];
}

// This message is only for Agent persistent policy conf.
message PersistPolicy {
    repeated PolicyItem             policy          = 1;
}

message PolicyItem {
    required BaseForward            forwardParams   = 1;
    required PolicyMatch            match           = 2;
    required PolicyAction           action          = 3;
    required uint32                 ratelimitid     = 4;
    optional bool                   bypass          = 5;
    optional uint32                 inboundRatelimitid = 6;     //inbound ratelimit id for distribute ratelimit
    optional uint32                 outboundRatelimitid = 7;    //outbound ratelimit id for distribute ratelimit
    optional bool                   exclusiveMode   = 8;
    optional bool                   transit         = 9;
    optional uint32                 customerId      = 10;
    optional uint32                 proxyProtocol   = 11;
    optional bool                   probeEnable     = 12;
}

message DnsPolicyItem {
    required BaseForward            forwardParams   = 1;
    required PolicyMatch            match           = 2;
    required PolicyAction           action          = 3;
    optional bool                   bypass          = 4;
}

message FiveTuple {
    repeated uint32                 ipProto         = 1;        // LW_IP_PROTO
    repeated IpType                 srcIps          = 2;
    repeated IpType                 dstIps          = 3;
    repeated Range                  srcPorts        = 4;
    repeated Range                  dstPorts        = 5;
    repeated Ipv6Type               srcIpv6s        = 6;
    repeated Ipv6Type               dstIpv6s        = 7;
}

message NatMatch {
    optional FiveTuple              fiveTuple       = 1;
    optional uint32                 netioType       = 2;        // LW_NETIO_TYPE
    repeated uint32                 wanId           = 3;
    repeated Connectivity           connectivity    = 4;
    repeated uint32                 lanId           = 5;
    optional uint32                 srcVpnId        = 6;        // Only for SNAT
    optional uint32                 inPolicyId      = 7;        // Only for SNAT
}

message PolicyMatch {
    optional uint32                 srcCustomerId   = 1;        // CustomerId and ClientId indicate local subnet name
    optional uint32                 srcClientId     = 2;
    optional uint32                 dstCustomerId   = 3;
    optional uint32                 dstClientId     = 4;
    optional uint32                 dstAccessUnitId = 5;
    optional uint32                 dscp            = 6;
    optional FiveTuple              fiveTuple       = 7;
    optional uint32                 inportType      = 8;
    optional uint32                 inportId        = 9;
    optional uint32                 outportType     = 10;
    optional uint32                 outportId       = 11;
    repeated PolicyMatchPort        srcPortIpsets   = 12;       // Used to define multi Lan/Wan ipset in policy match
    repeated PolicyMatchPort        dstPortIpsets   = 13;       // Same as srcPortIpsets
    optional uint32                 neighIpv4       = 15;
    optional Ipv6Cidr               neighIpv6       = 16;
    optional uint32                 inPolicyId      = 17;
    repeated PolicyMatchPort        inPort          = 18;
}

message PolicyMatchPort {
    required uint32                 portType        = 1;   // must be set, 0: reserved 1: lan 2: wan
    optional uint32                 portId          = 2;   // lanId or wanId
    optional uint64                 dynIpsetVersion = 3;
    optional uint64                 staticIpsetVersion = 4;
}

message SnatAction {
    required bool                   masquerade      = 1;        // If masquerade==1, then the following snatIp and snatPorts will be NULL.
    optional uint32                 snatIp          = 2;        // Only allow 1 snatIP.
    optional Range                  snatPorts       = 3;        // SNAT port range is optional
    optional bytes                  snatIpv6        = 4;
    repeated uint32                 snatIps         = 5;        //Multiple ipv4 addresse, up to 16
    repeated bytes                  snatIpv6s       = 6;        //Multiple ipv6 addresses, up to 16
    optional uint32                 natMode         = 7;        // LW_DP_NAT_MODE
    optional uint32                 natIpMode       = 8;        // LW_DP_NAT_IP_MODE
    repeated IpType                 snatIpV2        = 9;
    repeated Ipv6Type               snatIpv6V2      = 10;
}

message DnatAction {
    required uint32                 targetDstIp         = 1;        // Only one DNAT IP
    optional uint32                 targetDstPort       = 2;        // DNAT port is optional
    optional bytes                  targetDstIpv6       = 3;
    optional uint32                 targetDstVpnId      = 4;
    optional uint32                 natMode             = 5;        // LW_DP_NAT_MODE
    optional uint32                 natIpMode           = 6;        // LW_DP_NAT_IP_MODE
    repeated IpType                 targetDstIpV2       = 7;
    repeated Ipv6Type               targetDstIpv6V2     = 8;
}

message PolicySessionLimit {
    required uint32                 limitType       = 1;        // LW_CONF_RULE_PER_IP_LIMIT_TYPE 1: limit source ip 2: limit destination ip.
    required uint32                 sessionNumber   = 2;        // Specifies the maximum number of sessions. 0 indicates no limitation
}

message PolicyAction {
    required bool                   drop            = 1;
    optional uint32                 netioType       = 2 [deprecated=true]; // LW_NETIO_TYPE 3.0 previous version
    optional PolicyWan              wan             = 3;
    optional Connectivity           conn            = 4;
    optional TransConnection        transConn       = 5;
    optional uint32                 strategy        = 6;        // 0: available, 1: prefer, 2: LB required in 3.0 later version
    repeated PolicyWan              wans            = 7;
    repeated Connectivity           conns           = 8;
    repeated PolicyLan              lans            = 9;
    optional uint32                 outputType      = 10;       // LW_CONF_DP_IF_TYPE 3.0 later version
    optional bool                   accelerate      = 11;       // 0(default) means no accelerate, 1 means accelerate
    repeated PolicyOutput           policyOutput    = 12;       // Use this message in version 3.5
    optional uint32                 dscpValue       = 13;
    repeated PolicySessionLimit     sessionLimit    = 14;
    optional bool                   resubmit        = 15;
    optional uint32                 outPolicyId     = 16;
    optional bool                   revOutForce     = 17;
    repeated SecurityFeature        securityFeature = 18;
}

message SecurityFeature {
    required uint32                 type           = 1;
    required string                 id             = 2;
    optional string                 comwarePolicyName     = 3;   //string length 1-63
}

message PolicyOutput {
    required uint32                 outputType      = 1;       // LW_CONF_DP_IF_TYPE 3.0 later version
    optional PolicyWan              wan             = 2;
    optional Connectivity           conn            = 3;
    optional TransConnection        transConn       = 4;
    optional PolicyLan              lan             = 5;
    optional uint32                 outputVpnId     = 6;
    optional bool                   probeFlag       = 7;
}

message TransConnection {
    required uint32                 wanID           = 1;
}

message PolicyWan {
    required uint32                 id              = 1;
    optional uint32                 priority        = 2;        // 0(default) for low priority, 1 for high priority
    optional bool                   accelerate      = 3 [deprecated=true];
}

message PolicyLan {
    required uint32                 id              = 1;
    optional uint32                 priority        = 2;        // 0(default) for low priority, 1 for high priority
    optional bool                   accelerate      = 3 [deprecated=true];
}

message Connectivity {
    required uint32                 label           = 1;
    required uint32                 vni             = 2;
}

message DnsProxyItem {
    required uint32                 id              = 1;
    required uint32                 zone            = 2;
    optional uint32                 preId           = 3;
    repeated string                 domains         = 4;
    optional uint32                 serverIp        = 5;
    optional bool                   dualFlag        = 6;
    optional bool                   revalFlag       = 7;
}

message DnsmasqConf {
    required bool                   enable          = 1;
    required uint32                 operation       = 2;        // 0: reload, 1: reboot
    repeated DnsHostItem            dnsHosts        = 3;
    repeated DnsServerItem          dnsServers      = 4;
    repeated DnsMxHostItem          dnsMxHost       = 5;
    repeated DnsProxyItemV2         dnsProxies      = 6;
    optional bool                   persistentFlag  = 7;
    optional bool                   historyPersistent = 8;      // If the conf is persistent in history
    optional uint32                 vpnId           = 9;
}

// Return an MX record named "maildomain.com" with target servermachine.com and preference 50
message DnsMxHostItem {
    required string                 targetDomain    = 1;        // eg. servermachine.com
    required string                 sourceDomain    = 2;        // eg. maildomain.com
    required uint32                 preference      = 3;        // default is 50
}

message DnsHostItem {
    required string                 domain          = 1;
    required uint32                 ip              = 2;
    optional bytes                  ipv6            = 3;
}

message DnsServerItem {
    required uint32                 dnsServer       = 1;
    optional string                 ifname          = 2;
}

message DnsProxyItemV2 {
    repeated string                 domains         = 1;
    repeated uint32                 serverIps       = 2;
    repeated bytes                  serverIpv6s     = 3;
}

message SshProxySrv {
    required uint32                 type            = 1;        // LW_ORCH_ADDR_TYPE 1:ipAddr, 2:domain
    optional NetAddr                ipAddr          = 2;
    optional string                 domain          = 3;
}

message SshProxyItem {
    required bool                   enable          = 1;
    required uint32                 proxyServerIp   = 2;
    required uint32                 proxyServerPort = 3;
    required uint32                 clientRemotePort= 4;
    optional SshProxySrv            serverAddr      = 5;       // If serverAddr is not exist, use proxyServerIp.
}

message AccessAuditItem {
    required bool                   enable          = 1;
}

message DomainAuditItem {
    required bool                   enable          = 1;
}

message RateLimitItem {
    required uint32                 id              = 1;
    optional BandWidthConf          inbound         = 2;
    optional BandWidthConf          outbound        = 3;
}

message BandWidthConf {
    required uint32                 bandwidth       = 1;
    required uint32                 commitBurstSize = 2;
    required uint32                 excessBurstSize = 3;
}
// vincent
message AccessUnitItem {
    required uint32                 id              = 1;
    required string                 name            = 2;
    repeated IpType                 ipList          = 3;
    repeated string                 domainList      = 4;
    optional string                 url             = 5;
    optional uint64					version			= 6;
    optional uint32                 ipNum           = 7;       // ip count, used by agent for memory allocating in url download mode
    optional uint32                 domainNum       = 8;       // domain count, used by agent for memory allocating in url download mode
    optional bool                   persistentFlag  = 9;
    optional bool                   historyPersistent = 10;    // If the conf is persistent in history
    repeated Ipv6Type               ipv6List        = 11;
    optional uint32                 ipv6Num         = 12;      // ipv6 count, used by agent for memory allocating in url download mode
    optional ProbeItem              probeItem       = 13;
}

message ProbeItem {
    repeated uint32                 probeProtocol   = 1;        //  LW_PROBE_PROTOCOL
    required uint32                 netAddrType     = 2;        //  LW_NET_ADDR_TYPE 1:ipv4   2:ipv6
    repeated uint32                 dstIpv4List     = 3;
    repeated bytes                  dstIpv6List     = 4;
    repeated string                 dstDomain       = 5;
}

// link/tunnelRtt, zhanyang
message LinkItem {
    required uint32                 linkId          = 1;
    required uint32                 linkType        = 2;        // LW_LINK_TYPE
    required LinkPeer               initiator       = 3;
    required LinkPeer               responder       = 4;
    optional uint32                 role            = 5;        // 0:LW_LINK_ROLE_INITIATOR 1:LW_LINK_ROLE_RESPONDER
    optional uint32                 thresh          = 6;        // If orch is old version and thresh is not exist, then agent set default value 20 to datapath. If orch is new version, MUST send thresh to agent. 0 means disable link srtt report, other data means thresh value.
    optional uint32                 kaItv           = 7;        // keepalive interval in seconds
    optional uint32                 kaTimeout       = 8;        // keepalive timeout in seconds
    optional uint32                 protoVersion    = 9;
    optional bool                   persistentFlag  = 10;
    optional bool                   historyPersistent = 11;     // If the conf is persistent in history
    optional uint32                 linkMode        = 12;       // LW_LINK_MODE
    optional uint32                 netAddrType     = 13;       // LW_NET_ADDR_TYPE 1:ipv4 2:ipv6
}

message LinkPeer {
    required uint32                 customerId      = 1;        // pop is 0
    required uint32                 clientId        = 2;        // cpeid/popid
    required uint32                 wanId           = 3;        // pop ifId/ cpe wanId
    optional uint32                 port            = 4;
    optional uint32                 vpnId           = 5;
}

message CryptoConf {
    required uint32                 cryptoSuite     = 1;        // LW_CRYPTO_SUITE_TYPE
    optional uint32                 cipherKeyLen    = 2;        //å•ä½: å­—èŠ‚
    optional uint32                 hmacKeyLen      = 3;        //å•ä½: å­—èŠ‚
    optional string                 cipherKey       = 4;
    optional string                 hmacKey         = 5;
}

message TunnelRttItem {
    required uint32                 netId           = 1;
    required uint32                 vni             = 2;
    required uint32                 label           = 3;
    optional uint32                 wanId           = 4;
    optional uint32                 tunnelType      = 5;        // LW_TUNNEL_TYPE
    optional uint32                 localIp         = 6;
    optional uint32                 remoteIp        = 7;
    optional uint32                 passive         = 8;
    repeated uint32                 path            = 9;        // linkId array
    optional uint64                 pathTimestamp   = 10;
    optional uint32                 tcpTunnelNum    = 11;
    optional uint32                 udpTunnelNum    = 12;
    optional uint32                 kaInterval      = 13;
    optional uint32                 kaTimeout       = 14;
    optional EncryptionParams       encryptionParams= 15;
    optional Sla                    sla             = 16;
    optional uint32                 sessionId       = 17;
    optional uint32                 mode            = 18;       // LW_CONN_MODE
    optional uint32                 buddy           = 19;       // buddy connection id
    optional uint32                 reseqTimeout    = 20 [deprecated=true];
    optional uint32                 reseqBufferSize = 21 [deprecated=true];
    optional bool                   invalidFlag     = 22 [deprecated=true];
    optional uint32                 lanId           = 23;       // lanId must exist when mode is l2
    optional bool                   masterFlag      = 24;       // Only for dupConn, 1:conn id is the smaller one. 0:conn id is the bigger one.
    optional bool                   maxTxModeFlag   = 25;
    optional uint32                 minTxKBytes     = 26;
    optional uint32                 protoVersion    = 27;
    optional bool                   persistentFlag  = 28;
    optional bool                   historyPersistent = 29;     // If the conf is persistent in history
    optional uint32                 lttPortSeed     = 30;       // 0 ~ 63
    optional uint32                 customerId      = 31;       // which customer this LWConn belong to
    optional uint32                 peerId          = 32;       // Peer CPEID or POPID
    optional bytes                  localIpv6       = 33;
    optional bytes                  remoteIpv6      = 34;
    optional uint32                 netAddrType     = 35;       // LW_NET_ADDR_TYPE 1:ipv4(localIp&remoteIp) 2:ipv6(localIpv6&remoteIpv6)
    optional uint32                 mtu             = 36;
    optional CryptoConf             cryptoConf      = 37;       // Replace encryptionParams when CPE support new connection crypto features.
    optional bool                   recreateFlag    = 38;       // Notify datapath delete tunnel and create again.
    optional bool                   L2OnlyEncapIpHdrFlag = 39;  // encapsulation ip header for l2-only packet
    optional uint32                 vpnId           = 40;
    optional bool                   minUsage        = 41;
    optional bool                   backupFlag      = 42;
    optional string                 peerUid         = 43;
    optional bool                   simUserFlowFlag = 44;
    optional bool                   lttDelEopResetFlag = 45;
    optional bool                   clearDFFlag     = 46;
}

message PathChange {
    required uint32                 netId           = 1;
    required uint32                 vni             = 2;
    required uint32                 label           = 3;
    required uint32                 sessionId       = 4;
    repeated uint32                 path            = 5;        // linkId array
    required uint64                 pathTimestamp   = 6;
    optional uint32                 initRtt         = 7;
    optional uint32                 protoVersion    = 8;
}

message AUConfigResult_C2O {
    required uint32 accessUnitId                    = 1;
    required uint64 version                         = 2;
    required uint32 result                          = 3;
}

message EncryptionParams {
    required uint32                 algorithm       = 1;        //  LW_ENCRYPT_ALGORITHM
    optional string                 key             = 2;
    optional uint32                 keyLen          = 3;
}

message Sla {
    required uint32                 latencyLow      = 1;
    required uint32                 latencyHigh     = 2;
    required uint32                 bwLow           = 3;
    required uint32                 bwHigh          = 4;
    required uint32                 jitterLow       = 5;
    required uint32                 jitterHigh      = 6;
    optional uint32                 packetLossLow   = 7;
    optional uint32                 packetLossHigh  = 8;
}

//OSPF/BGP configure, zhiliang/yunpeng
message BgpConfigure {
    required bool                   enable          = 1;
    optional BgpBasic               bgpBasic        = 2;
    repeated PrefixList             prefixes        = 3;
    repeated AccessList             accesses        = 4;
    repeated BgpNeighbor            bgpNeighbors    = 5;
    repeated BgpNetwork             bgpNetworks     = 6;
    optional uint32                 vpnId           = 7;
}

message CpeUnreachableInfo {
    required uint32                 peerCustomerId  = 1;
    required uint32                 peerClientId    = 2;
    required bool                   cleanIpset      = 3;
    optional uint32                 vpnId           = 4;
}

message CpeUnreachNotify_O2C {
    required uint32                 peerCustomerId  = 1;
    required uint32                 peerClientId    = 2;
    required bool                   cleanIpset      = 3;
    optional uint32                 vpnId           = 4;
}

message CpeReachStateReport_C2O {
    required bool                   peerReachable   = 1;
    required uint32                 peerCustomerId  = 2;
    required uint32                 peerClientId    = 3;
    optional uint32                 vpnId           = 4;
}

message DistRatelimitBonus_O2C {
    required uint32                 id              = 1;        // Ratelimit instance ID
    optional uint64                 bonus           = 2;        // TokenBonus
    optional uint32                 customerId      = 3;
}

message BgpBasic {
    required uint32                 routerId        = 1;
    required uint32                 asNumber        = 2;
    optional uint32                 holdTime        = 3;
    optional uint32                 keepaliveTime   = 4;
    optional bool                   sendAsPathEnable = 5;   //report as-path or not
    optional bool                   recvAsPathEnable = 6;   //receive as-path or not
}

message BgpNeighbor {
    required uint32                 method              = 1;    // LW_METHOD
    required uint32                 ip                  = 2;
    required uint32                 asNumber            = 3;
    required bool                   defaultOriginate    = 4;
    required bool                   sendCommunity       = 5;
    optional string                 inPrefixListName    = 6;
    optional string                 outPrefixListName   = 7;
    optional string                 inAccessListName    = 8;
    optional uint32                 ebgpMultilhop       = 9;    // 1-255
    optional string                 password            = 10;   // 1 <= length <= 80
    optional uint32                 portType            = 11; 	// must be set, 0: reserved 1: lan 2: wan
    optional uint32                 portId              = 12; 	// lanId or wanId
    optional bool                   nextHopSelf         = 13;
    optional Ipv6Cidr               ipv6Neigh           = 14;
    optional uint32                 vpnId               = 15;
    optional uint32                 weight              = 19;   // 0-65535
    optional uint32                 prependAsPathLen    = 20;
    optional uint32                 ipv4UpdateSource    = 21;
    optional Ipv6Cidr               ipv6UpdateSource    = 22;
    optional bool                   neighborToPN        = 23;
    optional uint32                 allowasin           = 24;  // enable allowas-in <1-10>
    optional uint32                 advertisementInterval = 25; // 0-600
    optional bool                   routerReflectorClient = 26;
}

message BgpNetwork {
    required Cidr                   network             = 1;
    optional Ipv6Cidr               ipv6Network         = 2;
}

message RouteVersionSynConfig {
    required bool                   enable              = 1;
    optional uint32                 period              = 2;
}

message SynDynRouteVersion_C2O {
    repeated  DynRouteVersion       dynRouteVersion     = 1;
}

message DynRouteVersion {
    required uint32                 customerId          = 1;
    required uint32                 clientId            = 2;
    optional uint64                 timestamp           = 3;
    optional uint32                 portType            = 4; 	// must be set,0: reserved 1: lan 2: wan
    optional uint32                 portId              = 5; 	// lanId or wanId
    optional uint32                 vpnId               = 6;
}

message BgpSoftReset_O2C {
    optional uint32                 vpnId               = 1;
}

message BgpHardReset_O2C {
    optional uint32                 vpnId               = 1;
}
//OSPF configure, xiaoyun/yunpeng
message OspfConfigure {
    required bool                   enable          = 1;
    optional OspfBasic              ospfBasic       = 2;
    repeated OspfNetwork            networks        = 3;
    repeated PrefixList             prefixes        = 4;
    repeated OspfInterface          interfaces      = 5;
    repeated OspfNeighbor           neighbors       = 6;
    optional uint32                 vpnId           = 7;
    repeated OspfArea               areas           = 8;
}

message OspfBasic {
    required uint32                 routerId            = 1;
    optional uint32                 metric              = 2;    // 0-16777214
    optional string                 inPrefixListName    = 3;
    optional string                 outPrefixListName   = 4;
    optional uint32                 lsaType             = 5;    //3: summary-lsa 5: as-external-lsa
    optional uint32                 metricType          = 6;    //1: OE1 2: OE2
    optional uint32                 advertiseDefaultRoute = 7;  //0: not; 1: adverstise if exists; 2: always advertise
}

message OspfNetwork {
    required Cidr                   network         = 1;
    required uint32                 area            = 2;
    optional bool                   authDigest      = 3;    /* obsoleted    */
    optional uint32                 authType        = 4;    // 0: sample 1: md5 digest
}

message OspfInterface {
    required string                 ifname          = 1;
    optional OspfAuth               auth            = 2;
    optional uint32                 helloInterval   = 3;    // 1-65535
    optional uint32                 deadInterval    = 4;    // 1-65535
    optional Cidr                   network         = 5;
    optional uint32                 area            = 6;
    optional uint32                 networkType     = 7;    // 0: none 1:broadcast 2: non-broadcast 3: point-to-multipoint 4: point-to-point
    optional uint32                 portType        = 8; 	// must be set,0: reserved 1: lan 2: wan
    optional uint32                 portId          = 9; 	// lanId or wanId
    optional uint32                 priority        = 10;   // 0 ~ 255
}

message OspfAuth {
    required uint32                 authType        = 1;    // 0: sample 1: md5 digest
    optional uint32                 digestKeyId     = 2;    // 1-255
    required string                 authKey         = 3;    // if authType = 0, then maxKeyLen = 8; else if authType = 1, then maxKeyLen = 16
    optional string                 authKeyStr      = 4;    // if authType = 0, then maxKeyLen = 8; else if authType = 1, then maxKeyLen = 16
}

message OspfNeighbor {
    required uint32                 ip              = 1;
}

message OspfNssa {
    required uint32                 translatorRole  = 1;    /* 0: None 1: translate-always 2: translate-candidate 3:translate-never */
    optional bool                   noSummaryFlag   = 2;
}

message OspfArea {
    required uint32                 id              = 1;    /* 0-4294967295	            */
    optional uint32                 authType        = 2;    /* 0: sample 1: md5 digest  */
    optional OspfNssa               nssa            = 3;
}

//OSPF6 configure, xiaoyun/yunpeng
message Ospf6Configure {
    required bool                   enable          = 1;
    optional Ospf6Basic             ospf6Basic      = 2;
    repeated PrefixList             prefixes        = 3;
    repeated Ospf6Interface         interfaces      = 4;
    optional uint32                 vpnId           = 5;
}

message Ospf6Basic {
    required uint32                 routerId            = 1;
    optional uint32                 metric              = 2;    // 0-4294967295
    optional uint32                 metricType          = 3;    //1: OE1 2: OE2
    optional string                 inPrefixListName    = 4;
    optional string                 outPrefixListName   = 5;
}

message Ospf6Interface {
    required string                 ifname          = 1;
    optional uint32                 helloInterval   = 2;   // 1-65535
    optional uint32                 deadInterval    = 3;   // 1-65535
    optional uint32                 priority        = 4;   // 0 ~ 255
    optional uint32                 instanceId      = 5;   // 0 ~ 255
    optional uint32                 area            = 6;
    optional uint32                 networkType     = 7;   // 0: none 1:broadcast 4: point-to-point
    optional uint32                 portType        = 8;   // must be set,0: reserved 1: lan 2: wan
    optional uint32                 portId          = 9;   // lanId or wanId
}

message PrefixList {
    required string                 name            = 1;
    required uint32                 seq             = 2;    // 1-4294967295
    required bool                   permit          = 3;
    required Cidr                   ipPrefix        = 4;
    optional uint32                 le              = 5;    // 0-32
    optional uint32                 ge              = 6;    // 0-32
    optional Ipv6Cidr               ipv6Prefix      = 7;
}

message AccessList {
    required string                 name            = 1;
    required bool                   permit          = 2;
    required string                 expression      = 3;
}

message PublishedAUList {
    repeated uint32                 accessUnitId    = 1;
    optional uint32                 portType        = 2;    // must be set,0: reserved 1: lan 2: wan
    optional uint32                 portId          = 3;    // lanId or wanId
    optional uint32                 vpnId           = 4;
}

message Ipv6Type {
    optional  bytes                 ipv6            = 1;
    optional  Ipv6Cidr              ipv6Cidr        = 2;
    optional  Ipv6Range             ipv6Range       = 3;
}

message Ipv6Cidr {
    required bytes                  ipv6            = 1;
    required uint32                 ipv6Mask        = 2;
}

message Ipv6Range {
    required bytes                  ipv6Begin       = 1;
    required bytes                  ipv6End         = 2;
}

message IpType {
    optional  uint32                ip              = 1;
    optional  Cidr                  cidr            = 2;
    optional  Range                 ipRange         = 3;
}

message Cidr {
    required uint32                 ip              = 1;
    required uint32                 mask            = 2;
}

message MixCidr {
    required uint32                 cidrType        = 1;        //1:ipv4 2:ipv6
    optional Cidr                   ipv4Cidr        = 2;
}

message Range {
    required uint32                 begin           = 1;
    optional uint32                 len             = 2;
}
// configure end

message FragMsgInfo {
    required uint32                 Seq             = 1;
    required uint32                 TotalFragCnt    = 2;
    required uint32                 StartOffset     = 3;
    required uint32                 EndOffSet       = 4;
    required uint32                 TotalItemCnt    = 5;
}

//dynRoute, zhiliang/yunpeng
message DynRouteReport_C2O {
    required RouteTable             dynRouteTable   = 1;
    optional uint32                 dynRouteType    = 2;
}

message DynRouteMixReport_C2O {
    required uint32                 customerId      = 1;
    required uint32                 clientId        = 2;
    required uint64                 timestamp       = 3;
    repeated MixDynRouteItem        table           = 4;
}

message RouteRequest_C2O {
    repeated RouteTable             routeTables     = 1;
    optional uint32                 requestReason   = 2;
}

message Route_O2C {
    required RouteTable             routeTable   = 1;
}

message DynRouteMixPush_O2C {
    required uint32                 customerId      = 1;
    required uint32                 clientId        = 2;
    required uint64                 timestamp       = 3;
    optional bool                   persistentFlag  = 4;
    optional bool                   historyPersistent = 5;  // If the conf is persistent in history
    repeated MixDynRouteItem        table           = 6;
}

message RouteTable {
    required uint32                 customerId      = 1;
    required uint32                 clientId        = 2;
    repeated RouteItem              table           = 3;
    optional uint64                 timestamp       = 4;
    optional uint32                 requestReason   = 5;
    optional uint32                 portType        = 6; 	// must be set,0: reserved 1: lan 2: wan
    optional uint32                 portId          = 7; 	// lanId or wanId
    optional bool                   persistentFlag  = 8;
    optional bool                   historyPersistent = 9;  // If the conf is persistent in history
    optional uint32                 vpnId           = 10;
    optional FragMsgInfo            fragMsgInfo     = 11;
    optional uint32                 neighIpv4       = 12;
    optional Ipv6Cidr               neighIpv6       = 13;
    optional bool                   prependAsPathEnable =  14 [deprecated=true];
    optional uint64                 ipsetVersion    = 15;
    optional bool                   isStaticRoute   = 16;
}

message RouteItem {
    required uint32                 method          = 1;
    required Cidr                   addrs           = 2;
    repeated uint32                 asPath          = 3;
    optional Ipv6Cidr               ipv6Addrs       = 4;
}

message MixDynRouteItem {
    required uint32                 method          = 1;
    required MixCidr                addrs           = 2;
    repeated uint32                 asPath          = 3;
    required uint32                 portType        = 4; 	// must be set,0: reserved 1: lan 2: wan
    required uint32                 portId          = 5; 	// must be set, lanId or wanId
    optional uint32                 dynRouteType    = 6;
}

message BgpStatsReport_C2O {
    repeated NeighborStats          neighborStats   = 1;
}

message NeighborStats
{
    required uint32                 ip              = 1;
    required uint32                 status          = 2;       // LW_NEIGHBOR_STATUS
    required uint64                 timestamp       = 3;
    optional uint32                 portType        = 4; 	// must be set,0: reserved 1: lan 2: wan
    optional uint32                 portId          = 5; 	// lanId or wanId
    optional Ipv6Cidr               ipv6NeighIp     = 6;
    optional uint32                 vpnId           = 7;
    optional uint32                 customerId      = 8;
    optional uint32                 clientId        = 9;
    optional uint32                 ifState         = 10;  //ospf interface status
    optional uint32                 state           = 11;  // neighbor state
}

// upgrade & ipdetect, vincent
message UpgradeNotify_O2C {
    required string                 resultId        = 1;
    required string                 url             = 2;
    required string                 checksum        = 3;
    required string                 version         = 4;
    optional uint32                 commServerIp    = 11;
    optional uint32                 commServerPort  = 12;
    optional string                 commServerDomain= 13;
    optional uint32                 targetType      = 14;       // LW_UPGRADE_TARGET_TYPE 0 - CPE, 1 - POP, 2 - dCPE Image, 3 - 5 third/custom/dirver Patch
    optional uint32                 downloadTimeout = 15;       // seconds. download new package timeout
    repeated CsvrAddr               csvrList        = 16;
    optional bytes                  commServerIpv6  = 17;
    optional uint32                 upgradeTimeout  = 18;       // seconds.  Upgrade timeout
    optional bool                   haUpgradeBoth   = 19;       // if exists, means currently is upgrading HA both master/slave
}

message UpgradeNotifyReply_C2O {
    required string                 resultId        = 1;
}

message UpgradeResult_C2O {
    required string                 resultId        = 1;
    required bool                   result          = 2;
    repeated UpgradeResultVersion   version         = 3;
}

message UpgradeResultVersion {
    required uint32                 upgradeType     = 1;        // LW_UPGRADE_TARGET_TYPE
    required string                 upgradeVersion  = 2;
}

message IpDetect_O2C {
    repeated IpDetectItem           ipDetectItems   = 1;
}

message IpDetectItem {
    required uint32                 wanId           = 1;
    required string                 url             = 2;
}

message IpDetectReply_C2O {
    repeated IpDetectResultItem     result          = 1;
}

message IpDetectResultItem {
    required uint32                 wanId           = 1;
    required string                 url             = 2;
    required uint32                 result          = 3;
}

message LanStats {
    required InterfaceStats         lanStats        = 1;
    required uint32                 lanId           = 2;
    required bool                   isLanUp         = 3;
}
//stats items begin, no need reply, chenxu/lipeng
message StatsReport_C2O {
    optional SystemStats            systemStats     = 1;                        // old msg item: "system_stats"
    repeated WanStats               wanStats        = 2;                        // old msg item: "interface_rxtx_stats"
    repeated InterfaceStats         lanStats        = 3 [deprecated=true];      // old msg item: "interface_rxtx_stats"
    repeated ConnStats              connStats       = 4;                        // old msg item: "interface_rxtx_stats"
    repeated LinkStats              linkStats       = 5;                        // old msg item: "link_interface_stat"
    repeated PolicyStats            policyStats     = 6;                        // old msg item: "policy_rxtx_stats"
    optional uint64                 timestamp       = 7;                        // us
    repeated BandwidthStats         bandwidthStats  = 8 [deprecated=true];      // old msg item: "wan_bw_report"
    optional uint32                 totalActiveFlows= 9;
    repeated LanStats               lanStat         = 10;                       //replace lanStats and the old msg will be deprecated when no CPE used
    repeated LinkDiagnoseStats      linkDiagStats   = 11 [deprecated=true];     //replaced by diagnose module
    optional uint32                 lanOnlineIpNum  = 12;
    repeated NicStats               nicStats        = 13;
    optional uint32                 vpnId           = 14;
}

message StatsReportV2_C2O {
    optional uint32                 vpnId           = 1;
    required uint64                 timestamp       = 2;                        // us
    optional SystemStats            systemStats     = 3;
    repeated NicStats               nicStats        = 4;
    repeated WanStats               wanStats        = 5;
    repeated ConnStats              connStats       = 6;
    repeated LinkStats              linkStats       = 7;
    repeated PolicyStats            policyStats     = 8;
    optional uint32                 totalActiveFlows= 9;
    repeated LanStats               lanStat         = 10;
    optional uint32                 lanOnlineIpNum  = 11;
    repeated OnlineIpStats          onlineIpStats   = 12;
    repeated EngineStat             engineStat      = 13;
}

message OnlineIpStats {
    required uint32                 addrType        = 1;        //1:ipv4 2:ipv6
    repeated OnlineIpItem           onlineIpItem    = 2;
}

message GeneralStats
{
    required uint32  				reasDiscards           = 1;       // # of reassembly discards.
    required uint32  				reasBadFragDiscards    = 2;       // # of bad fragment discards.
    required uint32  				reasBadPacketDiscards  = 3;       // # of bad reassembled packets.
    required uint32  				reasBadChksumDiscards  = 4;       // # of bad reassembled checksum
    required uint32  				malformedDiscards      = 5;       // # of malformed packet discard
}

message TcpTraffic
{
    required uint32  				intfLanOutDiscards         = 1;   // # of LAN interface discards.
    required uint32  				intfWanOutDiscards         = 2;   // # of WAN interface discards.
    required uint32  				clsfRecvDiscards           = 3;   // # of classifier recv discards
    required uint32  				clsfSendDiscards           = 4;   // # of classifier send discards
    required uint32  				packetPoolLowDiscards      = 5;   // # of low-pool discards.
    required uint32  				packetBasePoolLowDiscards  = 6;   // # of low-base-pool discards.
    required uint32  				mssDiscards                = 7;   // # of segment size exceeds mss
    required uint32  				badAckDiscards             = 8;   // # of out-of-range ACKs.
    required uint32  				badPacketDiscards          = 9;   // # of invalid packets.
    required uint32  				flowNullDiscards           = 10;  // # of NULL-flow discards.
    required uint32  				flowDropDiscards           = 11;  // # of drop-action discards.
    required uint32  				flowDestroyDiscards        = 12;  // # of flow-destroy discards.
    required uint32  				flowDestroyAckDiscards     = 13;  // # of flow-destroy ACK discard
    required uint32  				schdQueueFullDiscards      = 14;  // # of queue full discards.
    required uint32  				schdAckQueueFullDiscards   = 15;  // # of ACK queue full discards.
    required uint32  				schdAckMergeDiscards       = 16;  // # of ACK-merge discard.
    required uint32  				accClsfSendDiscards        = 17;  // # of acc flow clsf send disc.
    required uint32  				accPacketPoolLowDiscards   = 18;  // # of acc flow pool low discs.
    required uint32  				accPacketMemLowDiscards    = 19;  // # of acc flow packet mem low.
}

message UdpTraffic
{
    required uint32  				intfLanOutDiscards         = 1;   // # of LAN interface discards.
    required uint32  				intfWanOutDiscards         = 2;   // # of WAN interface discards.
    required uint32  				clsfRecvDiscards           = 3;   // # of classifier recv discards
    required uint32  				clsfSendDiscards           = 4;   // # of classifier send discards
    required uint32  				packetPoolLowDiscards      = 5;   // # of low-pool discards.
    required uint32  				packetBasePoolLowDiscards  = 6;   // # of low-base-pool discards.
    required uint32  				flowNullDiscards           = 7;   // # of NULL-flow discards.
    required uint32  				flowDropDiscards           = 8;   // # of drop-action discards.
    required uint32  				flowDestroyDiscards        = 9;   // # of flow-destroy discards.
    required uint32  				schdQueueFullDiscards      = 10;  // # of queue full discards.
}

message MiscTraffic
{
    required uint32  				intfLanOutDiscards         = 1;   // # of LAN interface discards.
    required uint32  				intfWanOutDiscards         = 2;   // # of WAN interface discards.
    required uint32  				clsfRecvDiscards           = 3;   // # of classifier recv discards
    required uint32  				clsfSendDiscards           = 4;   // # of classifier send discards
    required uint32  				packetPoolLowDiscards      = 5;   // # of low-pool discards.
    required uint32  				packetBasePoolLowDiscards  = 6;   // # of low-base-pool discards.
    required uint32  				flowNullDiscards           = 7;   // # of NULL-flow discards.
    required uint32  				flowDropDiscards           = 8;   // # of drop-action discards.
    required uint32  				flowDestroyDiscards        = 9;   // # of flow-destroy discards.
    required uint32  				schdQueueFullDiscards      = 10;  // # of queue full discards.
}

message LttTraffic
{
    required uint32  				tunnelLimitFails           = 1; 	// # of tunnel over-limit create
    required uint32  				tunnelNatSipFails          = 2; 	// # of SIP NAT failures.
    required uint64  				tunnelNoRouteDiscards      = 3; 	// # of no-route discards.
    required uint64  				tunnelMtuDiscards          = 4; 	// # of discards due to MTU.
    required uint64  				tunnelFullDiscards         = 5; 	// # of tunnel-full discards.
    required uint64  				tunnelResDiscards          = 6; 	// # of discards due to no pkts.
    required uint64  				tunnelNatDiscards          = 7; 	// # of discards due to NAT fail
    required uint64  				noTunnelDiscards           = 8; 	// # of no-tunnel discards.
    required uint64  				conflictFlowDiscards       = 9; 	// # of conflict flow packets.
    required uint64  				l2HeaderTooBigDiscards     = 10;	// # of oversized L2 headers.
    required uint64  				cryptEncapFailDiscards     = 11;	// # of crypt encap fails.
    required uint64  				cryptEncapMtuDiscards      = 12;	// # of crypt encap too-bigs.
    required uint64  				cryptDecapFailDiscards     = 13;	// # of crypt decap fails.
    required uint64  				cryptNoFlowDiscards        = 14;	// # of crypt no-flow discards.
}

message EngineStat {
    required uint32                 engineId                   = 1;     //engineid = 65535 means total stats
    required GeneralStats           generalStat                = 2;        // IPv4 / IPv6 stats
    required uint32                 l2_UntunneledDiscards      = 3;        // L2 general statistics
    required uint64                 acquirePacketFails         = 4;        // # of packet acquire failures
    required uint64                 acquireOpaquePacketFails   = 5;        // # of opkt acquire failures
    required uint64                 cloneOpaquePacketFails     = 6;        // # of opkt clone failures
    required uint64                 tcpPacketLimitFails        = 7;        // # of tcp packet alloc fails
    required uint64                 createFlowFails            = 8;        // # of flow creations failures
    required uint64                 createTcpFlowFails         = 9;        // # of tcp flow creation fails
    required uint64                 createCompLinkFails        = 10;        // # of (de)comp link failures
    required uint64                 badComps                   = 11;       // # of (de)comp corrupted
    required uint32                 byteCacheEdgeFails         = 12;       // # of edge allocation failures
    required uint32                 acquirePacketBaseFails     = 13;       // # of pkt base acquire fails
    required TcpTraffic             tcpTraffic                 = 14;       // tcp traffic statistics
    required UdpTraffic             udpTraffic                 = 15;       // udp traffic statistics
    required MiscTraffic            miscTraffic                = 16;       // other protocol statistics
    required LttTraffic             lttTraffic                 = 17;       // Light TCP Tunnel statistics
    required uint32                 noSchedulerDiscards        = 18;       // # of no-scheduler discards
}

message OnlineIpItem {
    required IpAddr                 ip              = 1;
}

message LinkDiagnoseStats{
    required uint32                 linkID          = 1;
    required uint32                 role            = 2;        // 0 means send end, 1 means recv end
    required uint64                 txPackets       = 3;
    required uint64                 rxPackets       = 4;
    required uint64                 txCtrlPkts      = 5;
    required uint64                 rxCtrlPkts      = 6;
    optional uint64                 txPps           = 7;
    optional uint64                 rxPps           = 8;
    optional uint64                 txCtrlPps       = 9;
    optional uint64                 rxCtrlPps       = 10;
}

message InterfaceStats {
    required string                 interfaceName   = 1;
    required uint32                 interfaceType   = 2;        // LW_INTERFACE_STATS_TYPE
    required uint64                 rxBytes         = 3;
    required uint64                 txBytes         = 4;
    required uint64                 rxPackets       = 5;
    required uint64                 txPackets       = 6;
    required uint64                 rxBps           = 7;        //  rx Byte per second
    required uint64                 txBps           = 8;        //  tx  Byte per second
    required uint64                 rxPps           = 9;        //  rx Packets per Second
    required uint64                 txPps           = 10;       //  tx Packets per Second
    optional uint64                 smoothrxBps     = 11;       //  smooth rx Byte per second
    optional uint64                 smoothtxBps     = 12;       //  smooth tx  Byte per second
    optional uint64                 smoothrxPps     = 13;       //  smooth rx Packets per Second
    optional uint64                 smoothtxPps     = 14;       //  smooth tx Packets per Second
    optional uint64                 incRxBytes      = 15;
    optional uint64                 incTxBytes      = 16;
    optional uint64                 incRxPkts       = 17;
    optional uint64                 incTxPkts       = 18;
}
message WanPriStats {
    required uint32                 wanPriority     = 1;
    required uint64                 rxBytes         = 2;        //  Byte
    required uint64                 txBytes         = 3;        //  Byte
    required uint64                 rxBps           = 4;        //  Byte per second
    required uint64                 txBps           = 5;        //  Byte per second
    required uint64                 rxPackets       = 6;
    required uint64                 txPackets       = 7;
    required uint64                 rxPps           = 8;        //  rx Packets per Second
    required uint64                 txPps           = 9;        //  tx Packets per Second
    optional uint64                 smoothrxBps     = 10;       //  smooth rx Byte per second
    optional uint64                 smoothtxBps     = 11;       //  smooth tx  Byte per second
    optional uint64                 smoothrxPps     = 12;       //  smooth rx Packets per Second
    optional uint64                 smoothtxPps     = 13;       //  smooth tx Packets per Second
    optional uint64                 incRxBytes      = 14;
    optional uint64                 incTxBytes      = 15;
    optional uint64                 incRxPkts       = 16;
    optional uint64                 incTxPkts       = 17;
}

message NicStats {
    required string                 ifName          = 1;
    required uint64                 txErrPkts       = 2;
    required uint64                 rxErrPkts       = 3;
    required uint64                 txDropPkts      = 4;
    required uint64                 rxDropPkts      = 5;
    required uint64                 qdiscDropPkts   = 6;
    optional uint64                 txOverRuns      = 7;
    optional uint64                 rxOverRuns      = 8;
}

message WanStats {
    required InterfaceStats         wanInterface    = 1;
    required uint32                 wanID           = 2;
    required bool                   isWanUp         = 3;
    repeated WanPriStats			wanPriorityStats= 4;
}

message TunnelStats {
    required uint64                 rxBytes         = 1;        //  Byte
    required uint64                 txBytes         = 2;        //  Byte
    required uint64                 rxBps           = 3;        //  Byte per second
    required uint64                 txBps           = 4;        //  Byte per second
    required uint64                 rxPackets       = 5;
    required uint64                 txPackets       = 6;
    required uint64                 rxPps           = 7;        //  rx Packets per Second
    required uint64                 txPps           = 8;        //  tx Packets per Second
    optional uint64                 smoothrxBps     = 9;        //  smooth rx Byte per second
    optional uint64                 smoothtxBps     = 10;       //  smooth tx  Byte per second
    optional uint64                 smoothrxPps     = 11;       //  smooth rx Packets per Second
    optional uint64                 smoothtxPps     = 12;       //  smooth tx Packets per Second
    optional uint64                 incRxBytes      = 13;
    optional uint64                 incTxBytes      = 14;
    optional uint64                 incRxPkts       = 15;
    optional uint64                 incTxPkts       = 16;
}

message UserStats {
    required uint32                 smLatency       = 1;
    required uint32                 rtLatency       = 2;
    required uint64                 smJitter        = 3;
    required uint64                 rtJitter        = 4;
    required uint32                 smRxLossRate    = 5;
    required uint32                 rtRxLossRate    = 6;
    required uint32                 smTxLossRate    = 7;
    required uint32                 rtTxLossRate    = 8;
}

message SlaState {
    required bool                   isSrttAlarm     = 1;
    required bool                   isJitterAlarm   = 2;
    required bool                   isLossrateAlarm = 3;
    optional bool                   isRtSrttAlarm   = 4;    // set by 'realtimeLatency'
    optional bool                   isRtJitterAlarm = 5;    // set by 'realtimeJitter'
    optional bool                   isRtLossrateAlarm = 6;  // set by 'realtimeDualLossRate'
}

message ConnId {
    required uint32                 netId           = 1;
    required uint32                 vni             = 2;
    required uint32                 label           = 3;
}

message ConnStats {
    required InterfaceStats         connInterface   = 1;
    required uint64                 latency         = 2;       // smooth latency. These are user stats
    required uint64                 jitter          = 3;       // smooth jitter
    required uint32                 connStatus      = 4;       // UP(connStatus = 1), DOWN(connStatus = 2)
    optional uint32					lossRate		= 5;
    optional uint32                 sendLossRate    = 6;       // smooth send loss rate
    optional uint32                 recvLossRate    = 7;       // smooth recv loss rate
    optional uint64                 realtimeLatency = 8;
    optional uint64                 realtimeJitter  = 9;
    optional uint32                 realtimeSendLossRate = 10;
    optional uint32                 realtimeRecvLossRate = 11;
    optional TunnelStats            tunnelStats     = 12;      // tunnel stats
    optional UserStats              userStats       = 13;      // deprecated, engine stats use next tcpLttStats/nonTcpLttStats
    optional uint32                 policyId        = 14;      // policy id for transparent mode connection
    optional SlaState               slaState        = 15;
    optional ConnId                 connId          = 16;
    optional ConnId                 buddyConnId     = 17;
    repeated UserStats              tcpLttStats     = 18;
    repeated UserStats              nonTcpLttStats  = 19;
    optional uint32                 dualLossRate    = 20;       // smooth dual loss rate, calculate by dp
    optional uint32                 realtimeDualLossRate = 21;   // real time dual loss rate, calculate by dp
}

message LinkStats {
    required uint32                 linkID          = 1;
    required uint32                 linkType        = 2;        // LW_LINK_TYPE
    required uint32                 rtt             = 3;        // smooth latency
    required uint32                 pktLoss         = 4;        // smooth pkt loss
    required uint32                 peerPktLoss     = 5;        // smooth peer pkt loss
    required uint32                 jitter          = 6;        // smooth jitter
    optional uint64                 txBytes         = 7;
    optional uint64                 rxBytes         = 8;
    optional uint64                 txPackets       = 9;
    optional uint64                 rxPackets       = 10;
    optional uint64                 rxBps           = 11;       //  Byte per second
    optional uint64                 txBps           = 12;       //  Byte per second
    optional uint64                 rxPps           = 13;       //  rx Packets per Second
    optional uint64                 txPps           = 14;       //  tx Packets per Second
    optional uint64                 smoothrxBps     = 15;       //  smooth rx Byte per second
    optional uint64                 smoothtxBps     = 16;       //  smooth tx  Byte per second
    optional uint64                 smoothrxPps     = 17;       //  smooth rx Packets per Second
    optional uint64                 smoothtxPps     = 18;       //  smooth tx Packets per Second
    optional string                 srcIP           = 19;
    optional string                 dstIP           = 20;
    optional uint32                 realtimeRtt     = 21;
    optional uint32                 realtimePktLoss = 22;
    optional uint32                 realtimePeerPktLoss = 23;
    optional uint32                 realtimeJitter  = 24;
    optional uint64                 incRxBytes      = 25;
    optional uint64                 incTxBytes      = 26;
    optional uint64                 incRxPkts       = 27;
    optional uint64                 incTxPkts       = 28;
    optional bytes                  srcIpv6         = 29;
    optional bytes                  dstIpv6         = 30;
}

message TcpBuffData {
    required uint32                 recvBufSize     = 1;
    required uint32                 sendBufSize     = 2;
}

message SystemStats {
    repeated uint32                 cpuUsage        = 1;        //  cpuUsage = (value/100)%, e.g. 1234 means 12.34%
    required uint32                 memTotal        = 2;        //  MB
    required uint32                 memUsed         = 3;        //  MB
    required uint32                 diskTotal       = 4;        //  MB
    required uint32                 diskUsed        = 5;        //  MB
    repeated uint32                 cpuTemperature  = 6;        //  (degree centigrade) eg.365 means 36.5(degree centigrade)
    optional TcpBuffData            commSrvTcpBufData = 7;
}

message PolicyStats {
    required uint32                 policyId        = 1;
    required uint64                 rxBytes         = 2;        //  Byte
    required uint64                 txBytes         = 3;        //  Byte
    required uint64                 rxBps           = 4;        //  Byte per second
    required uint64                 txBps           = 5;        //  Byte per second
    required uint64                 rxPackets       = 6;
    required uint64                 txPackets       = 7;
    required uint64                 rxPps           = 8;         //  rx Packets per Second
    required uint64                 txPps           = 9;       //  tx Packets per Second
    optional uint32                 activeFlows     = 10;
    optional uint64                 smoothrxBps     = 11;       //  smooth rx Byte per second
    optional uint64                 smoothtxBps     = 12;       //  smooth tx  Byte per second
    optional uint64                 smoothrxPps     = 13;       //  smooth rx Packets per Second
    optional uint64                 smoothtxPps     = 14;       //  smooth tx Packets per Second
    optional bool                   exclusiveMode   = 15;
    optional uint64                 incRxBytes      = 16;
    optional uint64                 incTxBytes      = 17;
    optional uint64                 incRxPkts       = 18;
    optional uint64                 incTxPkts       = 19;
}


//access audit items begin, no need reply, jackie
message AccessAuditReport_C2O {
    repeated AccessAuditStats       accessAuditStats = 1;
}

message DomainAuditReport_C2O {
    repeated DomainAuditStats       domainAuditStats = 1;
}

message FlowReport_C2O {
    repeated FlowStats              flowStats       = 1;
}
message RatelimitReport_C2O {
    repeated RatelimitStats         ratelimitStats  = 1;
    optional uint64                 timestamp       = 2;
}
message FlowStats {
    required uint32                 srcIp           = 1;
    required uint32                 dstIp           = 2;
    required uint32                 srcPort         = 3;
    required uint32                 dstPort         = 4;
    required uint32                 protocol        = 5;
    required uint32                 policyId        = 6;
    required uint64                 rxPackets       = 7;
    required uint64                 txPackets       = 8;
    required uint64                 rxBytes         = 9;
    required uint64                 txBytes         = 10;
    optional bytes                  srcIpv6         = 11;
    optional bytes                  dstIpv6         = 12;
    optional uint32                 vpnId           = 13;
    optional uint32                 customerId      = 14;
    optional uint32                 outgoingType    = 15;   //Outgoing Type, LW_CONF_DP_IF_TYPE
    optional uint32                 outgoingId      = 16;   //Outgoing Interface id or LightWAN Connection ID according to outputType
    optional uint64                 createTime      = 17;
    optional uint32                 incomingType    = 18;   //incoming Type, LW_CONF_DP_IF_TYPE,equivalent to inPortType
    optional uint32                 incomingId      = 19;   //incoming Interface id or LightWAN Connection ID according ro incomingType,equivalent to inPortType
    optional bool                   relatedFlag     = 20;
}
message AccessAuditStats {
    required uint32                 srcIp           = 2;
    required uint32                 dstIp           = 3;
    required uint32                 srcPort         = 4;
    required uint32                 dstPort         = 5;
    optional uint32                 ipProtocol      = 6;
    required uint64                 startTime       = 7;
    required uint64                 endTime         = 8;
    required uint64                 rxBytes         = 9;
    required uint64                 txBytes         = 10;
    required string                 url             = 11;
    optional bytes                  srcIpv6         = 12;
    optional bytes                  dstIpv6         = 13;
    optional bool                   relatedFlag     = 14;
}

message DomainAuditStats {
    required uint32                 srcIp           = 1;
    required uint32                 dstIp           = 2;
    required string                 dstDomain       = 3;
    required uint64                 accessTime      = 4;
    required uint32                 policyId        = 5;
    required uint32                 policyStatus    = 6;  // 0: pass; 1: drop
    required bool                   fromLocal       = 7;  // Whether request is sent from local
    optional bytes                  srcIpv6         = 8;
    optional bytes                  dstIpv6         = 9;
    optional uint32                 vpnId           = 10;
    optional uint32                 customerId      = 11;
    optional bool                   relatedFlag     = 12;
}

message RatelimitStats {
    required uint32                 ratelimitID     = 1;
    required int64                  bucketSurplus   = 2;
    required uint64                 smoothedRate    = 3;
    optional uint32                 customerId      = 4;
    optional uint64                 matchedRate     = 5;
}

message ProbeConfigItem {
    optional uint32                 txPktInterval   = 1;        //  us
    optional uint32                 rxPktInterval   = 2;        //  us
    optional uint32                 txTotalPkt      = 3;        //  0 means periodic probe
    optional uint32                 rxTotalPkt      = 4;        //  0 means periodic probe
    optional uint32                 rxPktLength     = 5;        //  bytes
    optional uint32                 txPktLength     = 6;
    optional uint32                 rxBandwidth     = 7;        //  bps
    optional uint32                 txBandwidth     = 8;
    optional uint32                 durationTime    = 9;        //  ms
    optional uint32                 traceTtl        = 10;       //  Only for trace probe, max is 30
    optional string                 dstDomain       = 11;       //  Destination domain for ping probe task if dstip does not exist in fiveTuple; Domain name for DNS probe task
    optional uint32                 perPktTimeout   = 12;       //  us
    optional uint32                 lanId           = 13;       //  LAN ID
    optional uint32                 netAddrType     = 14;       //  LW_NET_ADDR_TYPE 1:ipv4   2:ipv6
    optional uint32                 wanId           = 15;       //  WAN ID
}

message ProbeTask {
    required uint32                 probeProtocol   = 1;        //  LW_PROBE_PROTOCOL
    required uint32                 frequency       = 2;        //  LW_PROBE_TASK_FREQUENCY, deprecated, preserved for Yunshixun
    required FiveTuple              match           = 3;
    required ProbeConfigItem        configure       = 4;
    optional uint32                 taskFrequency   = 5;        //  second. Probe task frequency for periodic task, 0 for one-time task
    optional uint32                 vpnId           = 6;
    optional bool                   reportOutput    = 7;
    optional bool                   allowRelated    = 8;
}

message ProbeObject {
    required uint32                 probeID         = 1;        //  same to policyID
    repeated ProbeTask              probeTasks      = 2;
    optional uint32                 pollingTime     = 3 [deprecated=true];
    optional string                 probeTaskId     = 4;    // probe task unique id
    optional uint32                 modId           = 5;       // LW_PROBE_MOD_ID
    optional uint32                 queueHandlerTimeoutMs   = 6;    // async msg worker timeout (ms)
}

message TransResult {
    required uint32                 latency         = 1;
    required uint32                 jitter          = 2;
    required uint32                 rxPktLoss       = 3;
    required uint32                 txPktLoss       = 4;
}

message SIPResult {
    optional bool                   isPktLoss       = 1;
    optional bool                   isNat           = 2;
    optional bool                   isComplete      = 3;
}

message TraceResultItem {
    required uint32                 Ip              = 1;
    repeated uint32                 rtt             = 2;        //  us
    optional bytes                  Ipv6            = 3;
    optional uint32                 ttl             = 4;
}

message TraceResult {
    required bool                   isReachable     = 1;
    repeated TraceResultItem        traceResItem    = 2;
    optional uint32                 dstIp           = 3;
}

message PingResult {
    required uint32                 latency         = 1;        // avg latency
    required uint32                 jitter          = 2;        // avg jitter
    required uint32                 pktLoss         = 3;        // thousandth
    optional uint32                 maxLatencyDiff  = 4;        // max latency - min latency
    optional uint32                 minLatency      = 5;
    optional uint32                 maxLatency      = 6;
    optional uint32                 dstIp           = 7;        // ping probe dst ip
    optional bytes                  dstIpv6         = 8;        // ping probe dst ipv6
}

message ResRecord {
    required uint32                 success         = 1;        // 0-success; 1-failed;
    optional uint32                 errorCode       = 2;        // 1-Format error; 2-Server failure; 3-Name Error; 4-Not Implemented; 5-Refused
    repeated NetAddr                dstAddr         = 3;        // resolution result of Domain name
}

message DNSResult {
    optional string                 cpeName         = 1;        // name of CPE
    optional NetAddr                srcAddr         = 2;        // src Ip for CPE
    repeated ResRecord	            resRecords      = 3;
    optional uint32                 latency         = 4;        // avg latency
    optional uint32                 jitter          = 5;        // avg jitter
    optional uint32                 pktLoss         = 6;        // thousandth
    optional uint32                 maxLatencyDiff  = 7;        // max latency - min latency
    optional uint32                 minLatency      = 8;
    optional uint32                 maxLatency      = 9;
}

message HttpResult {
    required uint32                 reachable       = 1;        // 0:unreachable 1:reachable
    optional uint32                 dstIp           = 2;        // http/https probe dst ip
}

message H323Result {
    optional bool                   isPktLoss       = 1;
    optional bool                   isNat           = 2;
    optional bool                   isComplete      = 3;
}

message WebRtcResult {
    optional bool                   isPktLoss       = 1;
    optional bool                   isNat           = 2;
    optional bool                   isComplete      = 3;
}

message RtspResult {
    optional bool                   isPktLoss       = 1;
    optional bool                   isNat           = 2;
    optional bool                   isComplete      = 3;
}

message GB28181Result {
    optional bool                   isPktLoss       = 1;
    optional bool                   isNat           = 2;
    optional bool                   isComplete      = 3;
}

message ProbeTaskResult {
    required uint32                 probeProtocol   = 1;        // LW_PROBE_PROTOCOL
    required uint32                 errorCode       = 2;
    optional TransResult            transResult     = 3;
    optional SIPResult              sipResult       = 4;
    required bool                   isTaskEnd       = 5;
    optional TraceResult            traceResult     = 6;
    optional PingResult             pingResult      = 7;
    optional DNSResult              dnsResult       = 8;
    optional HttpResult             httpResult      = 9;
    optional uint32                 outputType      = 10;       // LW_CONF_DP_IF_TYPE 3.0 later version
    optional uint32                 outputId        = 11;
    optional H323Result             h323Result      = 12;
    optional WebRtcResult           webrtcResult    = 13;
    optional RtspResult             rtspResult      = 14;
    optional GB28181Result          gb28181Result   = 15;
}

message ProbeResult {
    required uint32                 probeID         = 1;
    repeated ProbeTaskResult        taskResult      = 2;
    optional string                 probeTaskId     = 3;    // probe task unique id
    optional uint64                 fireTime        = 4;    // Start time for periodic task
    optional uint32                 modId           = 5;    // LW_PROBE_ORCH_MOD_ID
}

message ProbeResult_C2O {
    repeated ProbeResult            probeResult     = 1;
    optional uint64                 timestamp       = 2;        //  us
}

message MobileTrafficObject {
    repeated IpType                 acceleratingIpSet = 1;      // acceleratingIpSet: cidr or ip
    repeated uint32                 dns             = 2;        // dns
    required bool                   appListAccelerate = 3;      // accelerating appList or non-accelerating appList
    repeated string                 appList         = 4;        // appList
}

message EnableVPN {
    required bool                   enable          = 1;        // true means open VPN and false means disconnect VPN
    optional uint32                 errorCode       = 2;        // errorCode for disconnection VPN
    optional string                 dcpeId          = 3;        // DCPE ID
}

message EnableVPNReport_C2O {
    required uint32                 result          = 1;         // 0-success; 1-failed; Can be used for failure reason
    optional string                 dcpeId          = 2;         // DCPE ID
}

message FlowReportConfigure {
    required bool                   enable          = 1;
    optional uint32                 batchSize       = 2;
}

message PopDCpeInfoItem {
    required string                 name            = 1;         //authentication name
    optional string                 ipsecKey        = 2;  		 //authentication password
    optional uint32                 orchId          = 3;
    optional uint32                 customerId      = 4;
    optional uint32                 cpeId           = 5;
    optional string                 commAddr        = 6;
    optional uint32                 clientIp        = 7;
    repeated CsvrAddr               csvrList        = 8;
    optional bytes                  clientIpv6      = 9;
    optional string                 psk             = 10;
}

message PopDCpeReport_C2O {
    required uint32                 method          = 1;  		 // 1-create; 2-destory
    required string                 name            = 2;
    required uint32                 result          = 3;         // 0-success; >0 failed; Can be used for failure reason
}

message PopDCpeSupport {
    required bool                   enable          = 1;
    optional uint32                 ip              = 2;
    optional string                 psk             = 3;
    optional uint32                 docker1WanId    = 4; 		 //docker1WanId is internal interface for shadow POP. It is used for create C2P link for dCPE.
    optional bytes                  ipv6            = 5;
}

message PopDCpeClientStatusReport_C2O {
    required string                 name            = 1;
    required bool                   connected       = 2;
    required uint64                 timestamp       = 3;
}

message PopDCpeSupportReport_C2O {
    required uint32                 result          = 1;  		 // 0-success; 1-failed; Can be used for failure reason
    required bool                   enable          = 2;
    optional uint32                 docker1Ip       = 3;
    optional string                 dcpeVersion     = 4;
    optional bytes                  docker1Ipv6     = 5;
}

message PopDCpeClientStatusPeriodicReport_C2O {
    repeated PopDCpeClientStatusReport_C2O item       = 1;        // only include connected dcpe names
    optional string                 dcpeVersion       = 2;        // include dcpe version in period status report msg, in case dcpe image is upgraded without pop re-login
}

message VLanParam {
    required uint32                 vlanId            = 1;  // VLAN ID
    required string                 mainIfname        = 2;  // sub-interface's main interface
}

message OutgoingInfCfg {
    required uint64                 loadSharingThreshold         = 1;  // kbps
}

message ServiceWanBandwidth {
    required uint32                 inKbps          = 1;       // default 1000000
    required uint32                 outKbps         = 2;       // default 1000000
    required uint32                 inBurstMs       = 3;       // default 4 max 65535
    required uint32                 outBurstMs      = 4;       // default 4 max 65535
}

message ServiceWanConfig {
    required uint32                 wanId           = 1;        // id of the real WAN through which original traffic is received
    required IpType                 wanIp           = 2;        // ip of the real WAN through which original traffic is received
    required uint32                 serviceWanId    = 3;        // id of the virtual WAN to provide the service
    optional Ipv6Type               wanIpv6         = 4;
    optional ServiceWanBandwidth    serviceWanBw    = 5;        // bandwidth limit parameters
}

message IpsecDpd {
    required uint32                 dpdInterval     = 1;        // defines the period time interval, default=30s
    required uint32                 dpdTimeout      = 2;        // defines the timeout interval, default=30s
    required uint32                 dpdTries        = 3;        // Number of retransmissions to send before giving up, default 5
}

message IpsecGlobal {
    optional IpsecDpd               dpd             = 1;        // dead peer detection parameters
}

message IpsecConfig {
    required bool                   enable          = 1;        // enable IPsec service or not. true: enable; false: disable
    repeated ServiceWanConfig       ipsecWan        = 2;        // config of the wan(s) to provide the ipsec service
    optional bool                   persistentFlag  = 3;
    optional bool                   historyPersistent = 4;      // If the conf is persistent in history
    optional IpsecGlobal            global            = 5;      // ipsec global config
}

message IpsecConfigReport_C2O {
    required bool                   enable          = 1;        // enable IPsec service or not. true: enable; false: disable
    required uint32                 result          = 2;        // 0: succeed; 1: fail
}

message IpsecAlgos {
    repeated string                 ike             = 1;        // ipsec phase1 algorithms, e.g. 3des-sha1-modp1024. ikev1 only support 1 such group, ikev2 support multiple such groups
    repeated string                 esp             = 2;        // ipsec phase2 algorithms, e.g. aes128-sha256. ikev1 only support 1 such group, ikev2 support multiple such groups
}

message IpsecXauthKey {
    required string                 id              = 1;        // username/account
    required string                 password        = 2;        // password
}

message IpsecConnectionConfig {
    required uint32                 connId          = 1;        // unique Id of this ipsec connection
    optional uint32                 ikeVersion      = 2;        // 1: IKEv1; 2: IKEv2
    optional IpsecAlgos             algos           = 3;        // encryption/integrity/[dhgroup] algorithms for ipsec phase 1(ike) and phase 2(esp)
    optional string                 psk             = 4;        // preshared key
    optional IpType                 left            = 5;        // public IP of the CPE WAN through which IPsec traffic is handled
    repeated IpType                 leftSubnet      = 6;        // private subnets behind the CPE
    optional IpType                 right           = 7;        // site-to-site: public IP of the peer through which IPsec traffic is handled; remote-access: not used
    repeated IpType                 rightSubnet     = 8;        // site-to-site: private subnets behind the peer; remote-access: virtual ip pool for clients
    optional bool                   persistentFlag  = 9;
    optional bool                   historyPersistent = 10;     // If the conf is persistent in history
    optional IpType                 leftId          = 11;       // public NAT IP of the CPE WAN through which IPsec traffic is handled, in the case left is a private IP
    optional Ipv6Type               leftIpv6        = 12;
    optional Ipv6Type               rightIpv6       = 13;
    repeated Ipv6Type               leftSubnetIpv6  = 14;
    repeated Ipv6Type               rightSubnetIpv6 = 15;
    optional Ipv6Type               leftIdIpv6      = 16;
    optional uint32                 connType        = 17;       // 0: site-to-site; 1: remote-access(client-to-site)
    repeated IpsecXauthKey          xauthKeys       = 18;       // Xauth id & password pairs for remote-access mode connection
    optional bool                   aggressive      = 19;       // 0: main mode; 1: aggressive mode. IKEv1 only
    optional string                 leftIdStr       = 20;       // left id string(e.g. FQDN), usually used for connection over interface of dynamic IP addr(which is unknown beforehand)
    optional string                 rightIdStr      = 21;       // right id string(e.g. FQDN)
}

message IpsecConnectionConfigReport_C2O {
    required uint32                 connId          = 1;        // unique Id of an ipsec connection
    required uint32                 method          = 2;        // 1: add; 2: update; 3: delete
    required uint32                 result          = 3;        // 0: succeed; 1: fail
}

message IpsecConnectionStatusReport_C2O {
    required uint32                 connId          = 1;        // unique Id of an ipsec connection
    required bool                   connected       = 2;        // true: connected; false: disconnected
    required uint64                 timestamp       = 3;        // time when connected or disconnected
    optional string                 clientIp        = 4;        // client public IP
    optional string                 clientVirtualIp = 5;        // client assigned virtual IP
    optional string                 clientId        = 6;        // client Xauth id
}

message StpConfig {
    required bool                   enable          = 1;        // enable spanning tree protocol on the switch or not. true: enable; false: disable (default false)
    optional uint32                 macAgingTime    = 2;        // mac address aging time (default 300s)
    optional uint32                 bridgePriority  = 3;        // root bridge priority (default 0)
    optional uint32                 portPriority    = 4;        // port priority (default 1)
    optional uint32                 portCost        = 5;        // port cost (default 1)
    optional uint32                 helloInterval   = 6;        // interval to send hello message by root bridge (default 2s)
    optional uint32                 maxMessageAge   = 7;        // max alive time of bpdu message (default 20s)
    optional uint32                 forwardDelay    = 8;        // forward delay (default 15s)
}

message VirtualSwitchConfig {
    required uint32                 id              = 1;        // unique Id of this virtual switch
    required bool                   enable          = 2;        // enable the virtual switch or not. true: enable; false: disable
    optional uint32                 maxPorts        = 3;        // maximum permitted ports inside the virtual switch, including both physical and virtual ports
    optional StpConfig              stpConf         = 4;        // spanning tree protocol configurations
    optional bool                   enableVlan      = 5;        // set vlan filtering
    optional uint32                 mtu             = 6;        // set the virtual switch virtual/bindPhysical/uplink interface mtu value
}

message VirtualSwitchConfigReport_C2O {
    required uint32                 id              = 1;        // unique Id of this virtual switch
    required bool                   enable          = 2;        // enable the virtual switch or not. true: enable; false: disable
    required uint32                 result          = 3;        // 0: succeed; 1: fail
}

message LanTemplate {
    required uint32                 id              = 1;
    required uint32                 type            = 2;        // 0 virtual switch
    required string                 ifname          = 3;        // can use placeholder to generate ifname, such as veth{lanId}
    required bool                   l2              = 4;
    required bool                   persistentFlag  = 5;
    required bool                   historyPersistent = 6;      // If the conf is persistent in history
    required bool                   virtual         = 7;        // 0: physical lan; 1: virtual lan
    required IdGenerator            idGenerator     = 8;
}

message IdGenerator {
    repeated BitSetId               bitSetId        = 1;
}

message BitSetId {
    required uint64                 ids             = 1;
    required uint32                 section         = 2;        // the section of bitSet
}

message LanTemplateReport_C2O {
    required uint32                 id              = 1;
    required uint32                 type            = 2;        // 0: virtual switch
    required uint32                 method          = 3;        // 1: add; 2: edit; 3: delete
    required uint32                 result          = 4;        // 0: succeed; 1: fail
    repeated BitSetId               bitSetLanResponse = 5;      // every bit : 0 success, 1 fail
}

message WirelessWanNetworkStatusReport_C2O {
    repeated WirelessWanNetworkStatus wirelessWanNetworkStatus = 1;
}

message WirelessWanNetworkStatus {
    required uint32                 moduleModel       = 1;
    repeated uint32                 wanId             = 2;
    required uint32                 networkType       = 3;   //1:3G 2:LTE
    required uint32                 rsrp              = 4;   //Reference Signal Received Power
    required string                 mcc               = 5;   //Mobile Country code
    required string                 mnc               = 6;   //Mobile Network code
    required uint32                 lac               = 7;   //location area code
    required uint32                 ci                = 8;   //Cell Identifier
    required uint32                 sinr              = 9;   //Signal to Interference plus Noise Ratio
    required string                 imsi              = 10;  //International Mobile Subscriber Identity
    optional uint32                 dialState         = 11;  //dial state : 1 success ,0 fail
    optional uint64                 ciU64             = 12;  //Cell Identifier; ECI: 28 bits NCI: 36bits
}

message ServiceProxyConf {
    required bool                      enable                  = 1;
    optional AppProxyHttp              appProxyHttp            = 2; // Layer 7 Proxy
}

message AppProxyHttp {
    optional AppProxyHttpConf          appProxyHttpConf        = 1; // nginx http Parameters
    repeated AppProxyServer            appProxyServers         = 2; // nginx Server config
}

message AppProxyServer {
    optional AppProxyServerConf        appProxyServerConf      = 1; // nginx server Parameters
    repeated AppProxyLocation          appProxyLocations       = 2; // nginx Location config
}

message AppProxyLocation {
    required string                    matchRule               = 1; // nginx location rule
    required AppProxyLocationConf      appProxyLocationConf    = 2;
}

message AppProxyHttpConf {
    repeated Upstream                  upstreams               = 1; // Load balancing config
    optional GzipHttpConf              gzipConf                = 2;
    optional ProxyHttpConf             proxyConf               = 3;
    optional ProxyCacheHttpConf        cacheConf               = 4;
    optional SslHttpConf               sslConf                 = 5; // proxy ssl Param
}

message AppProxyServerConf {
    repeated ServerListen              listens                 = 1; // listen
    repeated string                    serverNames             = 2; // server Name
    optional GzipServerConf            gzipConf                = 3;
    optional ProxyServerConf           proxyConf               = 4;
    optional ProxyCacheServerConf      cacheConf               = 5;
    optional SslServerConf             sslConf                 = 6;
}

message AppProxyLocationConf {
    optional GzipLocationConf          gzipConf                = 1;
    optional ProxyLocationConf         proxyConf               = 2;
    optional ProxyCacheLocationConf    cacheConf               = 3;
}

message GzipPublicConf {
    optional bool                      enable                  = 1; // gzip Enable
    optional AppProxyBuffers           buffers                 = 2; // gzipBuffers, Sets the number and size of buffers used to compress a response.
    optional uint32                    compLevel               = 3; // gzipCompLevel, Sets a gzip compression level of a response. Acceptable values are in the range from 1 to 9
    optional uint32                    minLength               = 4; // gzipMinLength, Sets the minimum length of a response that will be gzipped.
    optional string                    stc                     = 5; // gzip static, Enables ("on") or disables ("off") checking the existence of precompressed files.
    repeated string                    types                   = 6; // gzipTypes, Enables gzipping of responses for the specified MIME types in addition to "text/html".
    optional bool                      vary                    = 7; // gzip vary,Enables or disables inserting the "Vary: Accept-Encoding" response header field
}
message GzipHttpConf {
    optional GzipPublicConf            publicConf              = 1;
}
message GzipServerConf {
    optional GzipPublicConf            publicConf              = 1;
}
message GzipLocationConf {
    optional GzipPublicConf            publicConf              = 1;
}

message ProxyPublicConf {
    // header
    repeated HeaderRule                addHeaders              = 1; // Adds the specified field to a response header provided that the response code
    repeated HeaderRule                setHeaders              = 2; // Allows redefining or appending fields to the request header passed to the proxied server.
    repeated string                    hideHeaders             = 3; // Allows redefining or appending fields to the request header passed to the proxied server.
    repeated string                    ignoreHeaders           = 4; // Ignore Client Abort
    optional string                    expires                 = 5; // expires time e.g: 1d  1h
    // char
    optional string                    charset                 = 6; // Adds the specified charset to the "Content-Type" response header field.
    repeated string                    charsetTypes            = 7; // Enables module processing in responses with the specified MIME types in addition to text/html.
    optional string                    defaultType             = 8; // Defines the default MIME type of a response.
    optional string                    httpVersion             = 9; // Http Version
    // timeout
    optional string                    proxyConnectTimeout     = 10; // Defines a timeout for establishing a connection with a proxied server.
    optional string                    proxyReadTimeout        = 11; // Defines a timeout for reading a response from the proxied server.
    optional string                    proxySendTimeout        = 12; // Sets a timeout for transmitting a request to the proxied server.
    optional string                    sendTimeout             = 13; // Sets a timeout for transmitting a response to the client.
    optional string                    clientBodyTimeout       = 14; // Defines a timeout for reading client request body.
    optional string                    keepAliveTimeout        = 15; // sets a timeout during which a keep-alive client connection will stay open on the server side.
    repeated string                    proxyRedirect           = 16; // Sets the text that should be changed in the "Location" and "Refresh" header fields of a proxied server response.
    optional bool                      requestBuffering        = 17;
    optional bool                      ignoreClientAbort       = 18; // Ignore Client Abort
    optional bool                      sendFileFunctionEnable  = 19; // enable sendFile or not.true(default): enable; false: disable
    repeated string                    allows                  = 20;
    repeated string                    denys                   = 21;
    optional string                    clientMaxBodySize       = 22; // Sets the maximum allowed size of the client request body
    optional Resolver                  resolver                = 23; // Confs name servers used to resolve names of upstream servers into addresses
}
message ProxyHttpConf {
    optional ProxyPublicConf           publicConf              = 1;
    optional string                    clientHeaderTimeout     = 2; // Defines a timeout for reading client request header. domain:http, server
}
message ProxyServerConf {
    optional ProxyPublicConf           publicConf              = 1;
    optional string                    clientHeaderTimeout     = 2; // Defines a timeout for reading client request header. domain:http, server
    optional ReturnDirective           returnDirective         = 3;
}
message ProxyLocationConf {
    optional ProxyPublicConf           publicConf              = 1;
    optional string                    proxyPass               = 2; // proxy Server addrss domain: location
    optional ReturnDirective           returnDirective         = 3;
}

message ProxyCachePublicConf {
    optional bool                      bufferingEnable         = 1; // Enables or disables buffering of responses from the proxied server.
    optional AppProxyBuffers           buffers                 = 2;
    optional string                    bufferSize              = 3;
    optional string                    busyBuffersSize         = 4;
    optional string                    tempFileWriteSize       = 5;
    optional string                    maxTempFileSize         = 6;
    optional bool                      cacheEnable             = 7;
    optional string                    key                     = 8; // Defines a key for caching
    repeated AppProxyCacheValid        valids                  = 9; // sets caching time for different response codes
}
message ProxyCacheHttpConf {
    optional ProxyCachePublicConf      publicConf              = 1;
}
message ProxyCacheServerConf {
    optional ProxyCachePublicConf      publicConf              = 1;
}
message ProxyCacheLocationConf {
    optional ProxyCachePublicConf      publicConf              = 1;
}

message Upstream {
    required string                    name                    = 1; // upstream name
    repeated UpstreamServer            servers                 = 2; // upstream Server
    optional bool                      ipHashEnable            = 3;
    optional bool                      leastConnEnable         = 4;
}

message UpstreamServer {
    required string                    serverAddr              = 1; // Sets the address and port for IP
    optional uint32                    weight                  = 2;
    optional uint32                    maxFails                = 3; // max Fails
    optional string                    failTimeout             = 4; // fail Timeout
    optional bool                      down                    = 5;
    optional bool                      backup                  = 6;
}

message Resolver {
    repeated string                    ipAddrs                 = 1; // Confs name servers used to resolve names of upstream servers into addresses
    optional string                    valid                   = 2; // valid time. eg 1d 1h
}

message SslPublicConf {
    repeated string                    certificateNames        = 1; // ssl Certificate file name
    repeated string                    certificateKeyNames     = 2; // ssl Certificate  key file name
    optional bool                      preferServerCiphers     = 3; // sslPreferServerCiphers, Server passwords that rely on SSLv3 and TLSv1 protocols will take precedence over client passwords
}
message SslHttpConf {
    optional SslPublicConf             sslConf                 = 1;
}
message SslServerConf {
    optional SslPublicConf             sslConf                 = 1;
}

message ServerListen {
    optional string                    listenAddr              = 1;
}

message AppProxyBuffers {
    required uint32                    num                     = 1; // Buffers Num
    required string                    size                    = 2; // Buffers Size
}

message HeaderRule {
    required string                    field                   = 1;
    required string                    value                   = 2;
    optional bool                      always                  = 3;
}

message AppProxyCacheValid {
    repeated uint32                    statusCodes             = 1; // status Code
    optional string                    cacheTime               = 2; // cache Time e.g: 1d  1h
}

message ReturnDirective {
    optional uint32                    code                    = 1;
    optional string                    text                    = 2;
}

message CryptoMsg {
    required CryptoCommHdr                  hdr                         = 1;
    optional CryptoRegisterReq              registerReq                 = 2;
    optional CryptoRegisterReply            registerReply               = 3;
    optional CryptoOrchKeyNotify            orchKeyNotify               = 4;
    optional CryptoKeyNotifyReply           orchKeyNotifyReply          = 5;
    optional CryptoIntraDomainReq           intraDomainReq              = 6;
    optional CryptoIntraDomainNotify        intraDomainNotify           = 7;
    optional CryptoIntraDomainNotifyReply   intraDomainNotifyReply      = 8;
    optional CryptoKeyNotify                keyNotify                   = 9;
    optional CryptoKeyNotifyReply           keyNotifyReply              = 10;
    optional CryptoKeyRecoveryReq           keyRecoverReq               = 11;
    optional CryptoWriteOffNotify           writeOffNotify              = 12;
    optional CryptoWriteOffNotifyReply      writeOffNotifyReply         = 13;
    optional CryptoModeNotify               modeNotify                  = 14;
    optional CryptoModeNotifyReply          modeNotifyReply             = 15;
    optional CryptoModuleSyncReq            moduleSyncReq               = 16;
    optional CryptoModuleSyncEndReply       moduleSyncEndReply          = 17;
    optional CryptoClusterNotify            clusterNotify               = 18;
    optional CryptoClusterNotifyReply       clusterNotifyReply          = 19;
}

message CryptoCommHdr {
    required string                 initiatorUid    = 1;
    required string                 responderUid    = 2;
    required uint64                 timestamp       = 3;
    optional uint32                 initiatorDevType = 4;   //LW_CRYPTO_REGISTER_DEV_TYPE
    optional uint32                 responderDevType = 5;
}

message CryptoDevInfo {
    required string                 cardSN          = 1;    //cardSN or UkeySN: decided by deviceType
    required uint32                 deviceType      = 2;    //LW_CRYPTO_REGISTER_DEV_TYPE
    required string                 uid             = 3;
    optional string                 dikPk           = 4;
    optional uint32                 cryptoEquipType = 5;    // LW_CRYPTO_EQUIP_TYPE
}

message CryptoAccountInfo {
    required  uint32                 customerId      = 1;
    required  string                 username        = 2;
}

message CryptoRegisterReq {
    required CryptoDevInfo          devInfo         = 1;
    optional CryptoAccountInfo      accountInfo     = 2;
}

message CryptoRegisterReply {
    required CryptoDevInfo          devInfo         = 1;
    required uint32                 result          = 2;
    optional string                 csdpDikPk       = 3;
    optional string                 keksDev         = 4;
    optional string                 keksCsdp        = 5;
    optional CryptoAccountInfo      accountInfo     = 6;
    repeated CryptoClusterKeyItem   csdpClusterKeks = 7;  //use for csdp, use csdp dik pk encryption
    repeated CryptoClusterKeyItem   csdpClusterDikPk= 8;  //use for cpe
    optional uint64                 csdpVersion     = 9;  //used by csdp register, means cluster version of csdp
}

message CryptoOrchKeyNotify {
    required string                 orchDikPk       = 1;
}

message CryptoModuleSyncReq {
    optional CryptoIntraDomainReq   intraDomainReq  = 1;
    optional CryptoAccountInfo      accountInfo     = 2;
    optional CryptoDevInfo          devInfo         = 3;
    optional CryptoClusterSyncReq   clusterSyncReq  = 4;
}

message CryptoClusterInfo {
    required uint32                 clusterType     = 1; // LW_CRYPTO_PART
    required uint64                 version         = 2;
}

message CryptoClusterSyncReq {
    repeated CryptoClusterInfo      clusterInfo     = 1;
}

message CryptoModuleSyncEndReply {
    required uint32                 result          = 1;
}

message CryptoClusterKeyItem {
    required uint32                 uid             = 1; // not used, we use uidString instead
    required uint32                 keyType         = 2; // LW_CRYPTO_KEY_TYPE
    required string                 key             = 3;
    optional string                 uidString       = 4;
}

message CryptoClusterNotify {
    required uint32                 operationType   = 1; // LW_CRYPTO_CLUSTER_OPERATION_TYPE
    required uint32                 clusterType     = 2; // LW_CRYPTO_PART
    repeated CryptoClusterKeyItem   diks            = 3 [deprecated=true];
    optional string                 requestId       = 4;
    optional uint64                 version         = 5;
    repeated CryptoClusterKeyItem   keys            = 6;
}

message CryptoClusterKeyReplyItem {
    required string                 uidString       = 1;
    required uint32                 keyType         = 2; // LW_CRYPTO_KEY_TYPE
    required uint32                 result          = 3;
}

message CryptoClusterNotifyReply {
    required uint32                 result          = 1; //not used, we use clusterKeyReplies instead
    optional string                 requestId       = 2;
    repeated CryptoClusterKeyReplyItem  clusterKeyReplies   = 3;
}

message CryptoOrchKeyNotifyReply {
    required uint32                 result          = 1;
}

message CryptoIntraDomainDevItem {
    required string                     devUid          = 1;
    optional string                     dikPk           = 2;
    optional uint32                     opAttr          = 3;    //LW_CRYPTO_INTRA_DOMAIN_OP_ATTR add/delete
}

message CryptoIntraDomainUpdate {
    required uint64                     versionFrom     = 1;
    required uint64                     versionTo       = 2;
    repeated CryptoIntraDomainDevItem   devItems        = 3;
}

message CryptoIntraDomainNotify {
    optional string                     domainId        = 1;
    required uint32                     notifyType      = 2;    //LW_CRYPTO_INTRA_DOMAIN_NOTIFY_TYPE
    repeated CryptoIntraDomainUpdate    updates         = 3;
    optional uint64                     version         = 4;
    optional string                     requestId       = 5;
}

message CryptoIntraDomainReq {
    optional string                     domainId        = 1;
    optional uint64                     version         = 2;
    optional string                     requestId       = 3;
}

message CryptoIntraDomainNotifyReply {
    required uint32                 notifyType      = 1;        //LW_CRYPTO_INTRA_DOMAIN_NOTIFY_TYPE
    required uint32                 result          = 2;
    optional string                 requestId       = 3;
}

message CryptoKeyItem {
    required uint32                 keyType         = 1;
    optional string                 uuid            = 2;
    optional string                 key             = 3;
    optional string                 keyCsdp         = 4;
    repeated CryptoClusterKeyItem   csdpKeys        = 5;
}

message CryptoKeyNotify {
    required uint32                 operationType   = 1;    //LW_CRYPTO_KEY_NOTIFY_TYPE
    repeated CryptoKeyItem          keyItem         = 2;
}

message CryptoKeyNotifyReply {
    required uint32                 operationType   = 1;    //LW_CRYPTO_KEY_NOTIFY_TYPE
    repeated CryptoKeyItem          keyItem         = 2;
    required uint32                 result          = 3;
}

message CryptoKeyRecoveryReq {
    repeated uint32                 keyType         = 1;
}


message  CryptoWriteOffNotify {
    required CryptoDevInfo          devInfo         = 1;
    optional uint64                 csdpVersion     = 2;    //used by csdp write-off, means cluster version of csdp
}

message  CryptoWriteOffNotifyReply {
    required CryptoDevInfo          devInfo         = 1;
    required uint32                 result          = 2;
}

message CryptoModeNotify {
    required uint32                 mode            = 1;	//LW_CRYPTO_MODE_TYPE
}

message CryptoModeNotifyReply {
    required uint32                 result          = 1;
}

message WanSetSubInterface {
    required uint32                 wanId             = 1;
    required string                 ifname            = 2;
}

message Uint32Interval {       //Represents a numerical interval from low to high: [low, high], low <= high
    required uint32            low                         = 1;
    required uint32            high                        = 2;
}

message Engine {
    optional uint32             maxFlowNum                 = 1;
    optional uint32             maxAccTcpNum               = 2;
    optional uint32             maxNumOfCompFlows          = 3;
}

message RTOLimit {
    optional uint32                maxRtoBackOffCnt        = 1;   //[0, 20]
    optional uint32                maxRtoMs                = 2;   //[0, 600000],      MaxRtoMS = 0 means unlimited
}

message Ipv4Filter {
    required uint32                ipv4                    = 1;
    required uint32                prefixLen               = 2;
}

message Ipv6Filter {
    required bytes                 ipv6                    = 1;
    required uint32                prefixLen               = 2;
}

message IpFilters {
    repeated Ipv4Filter            ipv4Filter              = 1;
    repeated Ipv6Filter            ipv6Filter              = 2;
}

message EngineConfigure {
    // single parameters
    // proc
    optional bool                   conservMode             = 1 [deprecated=true];            //                    default value: 0            0: feature off    1: feature on
    optional bool                   dataCompEnable          = 2 [deprecated=true];            //                    default value: 0            0: feature off    1: feature on
    optional bool                   engSysEnable            = 3 [deprecated=true];            //                    default value: 1            0: feature off    1: feature on
    optional bool                   maxTxEnable             = 4 [deprecated=true];            //                    default value: 0            0: feature off    1: feature on
    optional bool                   pcapEnable              = 5 [deprecated=true];            //                    default value: 0            0: feature off    1: feature on
    optional bool                   shaperEnable            = 6 [deprecated=true];            //                    default value: 1(cpe/lotserver) 0(lotwan)     0: feature off    1: feature on
    optional bool                   tcpAccEnable            = 7 [deprecated=true];            //                    default value: 1            0: feature off    1: feature on
    optional bool                   trackRandomLoss         = 8 [deprecated=true];            //                    default value: 1            0: feature off    1: feature on
    // cmd
    optional uint32                 displayLevel            = 9 [deprecated=true];            //                    default value: 10(cpe) 5(lotwan/lotserver)
    optional uint32                 udpBurst                = 10 [deprecated=true];           //                    default value: N/A
    optional uint32                 rxLoopCnt1              = 11 [deprecated=true];           //                    default value: 4
    optional uint32                 rxLoopCnt2              = 12 [deprecated=true];           //                    default value: 64
    optional uint32                 pcapFilterProto         = 13 [deprecated=true];           //                    default value: 0
    optional uint32                 pcapFilterSplit         = 14 [deprecated=true];           //                    default value: 0
    optional uint32                 pcapFileSize            = 15 [deprecated=true];           //                    default value: 104857600
    optional uint32                 pcapPktLen              = 16 [deprecated=true];           //                    default value: 256
    optional uint32                 pcapFileNum             = 17 [deprecated=true];           //                    default value: 2
    optional uint32                 reservePage             = 18 [deprecated=true];           //                    default value: 0(cpe) 81920(lotwan) 0(lotserver)
    optional uint32                 initialCwndLan          = 19 [deprecated=true];           //                    default value: 16384(cpe) 32(lotwan/lotserver)
    optional uint32                 initialCwndWan          = 20 [deprecated=true];           //                    default value: 44(cpe) 32(lotwan) 22(lotserver)
    optional uint32                 maxCwndLan              = 21 [deprecated=true];           //                    default value: 65536(cpe) 16KB(lotwan/lotserver)
    optional uint32                 maxCwndWan              = 22 [deprecated=true];           //                    default value: 83388608(cpe) 4MB(lotwan/lotserver)
    optional uint32                 maxAdvWinLan            = 23 [deprecated=true];           //                    default value: 60(cpe) 16(lotwan/lotserver)
    optional uint32                 maxAdvWinWan            = 24 [deprecated=true];           //                    default value: 0
    optional uint32                 halfCwndMinSRtt         = 25 [deprecated=true];           //                    default value: 500
    optional uint32                 halfCwndLossRateShift   = 26 [deprecated=true];           //                    default value: 3
    optional uint32                 halfCwndLowLimit        = 27 [deprecated=true];           //                    default value: 0
    optional uint32                 srttThresh              = 28 [deprecated=true];           //                    default value: 0
    optional uint32                 maxTxMinSsThresh        = 29 [deprecated=true];           //                    default value: 1MB
    optional uint32                 maxTxMinAdvWinWan       = 30 [deprecated=true];           //                    default value: 1MB
    optional uint32                 maxTxEffectiveMS        = 31 [deprecated=true];           //                    default value: 0
    optional uint32                 flowShortTimeout        = 32 [deprecated=true];           //                    default value: 30000
    optional uint32                 maxAccFlowTxKbps        = 33 [deprecated=true];           //                    default value: 0      0 means not limited
    optional uint32                 maxReasL4Size           = 34 [deprecated=true];           //                    default value: 3940(cpe) 3960(lotwan/lotserver)
    optional uint32                 retranDupAckCnt         = 35 [deprecated=true];           //                    default value: 0
    optional uint32                 retranWaitListMS        = 36 [deprecated=true];           //                    default value: 32
    optional uint32                 reseqPacketCnt          = 37 [deprecated=true];           //                    default value: 3
    optional uint32                 rtoScale                = 38 [deprecated=true];           //                    default value: 1(cpe) N/A(lotwan/lotserver)
    optional uint32                 tcpFlags                = 39 [deprecated=true];           //                    default value: N/A
    optional bool                   bypassOverFlows         = 40 [deprecated=true];           //                    default value: 1            0: feature off    1: feature on
    optional uint32                 smBurstMS               = 41 [deprecated=true];           //                    default value: 16
    optional uint32                 smBurstMin              = 42 [deprecated=true];           //                    default value: 16000(cpe) 15000(lotwan) 6000(lotserver)
    optional uint32                 smBurstTolerance        = 43 [deprecated=true];           //                    default value: 32768(cpe) 32KB(lotwan/lotserver)
    optional uint32                 smMinKbps               = 44 [deprecated=true];           //                    default value: 512(cpe) N/A(lotwan/lotserver)
    optional uint32                 dbcMinInFlight          = 45 [deprecated=true];           //                    default value: 0
    optional uint32                 lttPort                 = 46 [deprecated=true];           //                    default value: 18000(cpe) 18000(lotwan) N/A(lotserver)
    optional uint32                 lttSipPort              = 47 [deprecated=true];           //                    default value: 0(cpe) N/A(lotwan) 5060(lotserver)
    optional uint32                 lttSynRetries           = 48 [deprecated=true];           //                    default value: 30(cpe) N/A(lotwan)  15(lotserver)
    optional uint32                 lttFailWaitSec          = 49 [deprecated=true];           //                    default value: 3(cpe)  N/A(lotwan) 60(lotserver)
    optional uint32                 lttIdleSec              = 50 [deprecated=true];           //                    default value: 1200(cpe)  N/A(lotwan) 1200(lotserver)
    optional uint32                 shortRttMS              = 51 [deprecated=true];           //                    default value: 0(cpe) N/A(lotwan) 10(lotserver)
    optional uint32                 synRetranMS             = 52 [deprecated=true];           //                    default value: 0 0 means disabled
    optional uint32                 pmtuBhRetrans           = 53 [deprecated=true];           //                    default value: 4(cpe) 5(lotwan) 5(lotserver)
    optional uint32                 ultraBoostWin           = 54 [deprecated=true];           //                    default value: 0
    optional bool                   shrinkPacket            = 55 [deprecated=true];           //                    default value: 0            0: feature off    1: feature on
    optional bool                   rsc                     = 56 [deprecated=true];           //                    default value: 0            0: feature off    1: feature on
    optional bool                   gso                     = 57 [deprecated=true];           //                    default value: 0            0: feature off    1: feature on
    optional uint32                 mpoolMaxCache           = 58 [deprecated=true];           //                    default value: 10485760(cpe) N/A(lotwan) N/A(lotserver)
    optional uint32                 lttSynRetryMS           = 59 [deprecated=true];           //                    default value: 1000(cpe) N/A(lotwan) 1000(lotserver)
    optional uint32                 lttSynPending           = 60 [deprecated=true];           //                    default value: 16(cpe) N/A(lotwan) 16(lotserver)
    // multi parameters
    optional Engine                 engine                  = 61 [deprecated=true];           //                    default value: maxFlowNum = 1000000  maxAccTcpNum = 500000  maxNumOfCompFlows = 0
    optional Uint32Interval         minSsThresh             = 62 [deprecated=true];           //                    default value: low = 8, high = 24
    optional RTOLimit               rtoLimit                = 63 [deprecated=true];           //                    default value: MaxRtoBackOffCnt = 5 , MaxRtoMs = 0
    optional Uint32Interval         l2wQLimit               = 64 [deprecated=true];           // [32, 65536],       default value: low = 256, high = 2048
    optional Uint32Interval         w2lQLimit               = 65 [deprecated=true];           // [32, 65536],       default value: low = 512, high = 8192
    optional Uint32Interval         dbcRttThreshMS          = 66 [deprecated=true];           //                    default value: low = 400, high = 1000
    optional Uint32Interval         lttMaxDelayMS           = 67 [deprecated=true];           // [0, 10000],        default value: low = 0,   high = 500
    optional Uint32Interval         lttL2WTQLimit           = 68 [deprecated=true];           // [32, 65536],       default value: low = 512, high = 8192
    optional Uint32Interval         lttL2WUQLimit           = 69 [deprecated=true];           // [32, 65536],       default value: low = 512, high = 8192
    optional Uint32Interval         lttW2LTQLimit           = 70 [deprecated=true];           // [32, 65536],       default value: low = 512, high = 8192
    optional Uint32Interval         lttW2LUQLimit           = 71 [deprecated=true];           // [32, 65536],       default value: low = 512, high = 8192
    optional Uint32Interval         taskSchedDelay          = 72 [deprecated=true];           //                    default value: low = 100, high = 100

    optional uint32                 pmtu_timeout_ms         = 73 [deprecated=true];           // [0, 3600000],      default value: 0 / 600000(version defined FEATURE_PMTU_RECOVER)
    optional uint32                 packet_pool_size        = 74 [deprecated=true];           // [0, max]           default value: 256            max = (Memory * 70%)/4000/cpuNum
    optional uint32                 g_LttMaxNum             = 75 [deprecated=true];           //                    default value: 1024
    optional uint32                 maxQuickAcks            = 76 [deprecated=true];           // [16, 512],         default value: 128
    optional uint32                 recoveryQuickAcks       = 77 [deprecated=true];           // [0, 256],          default value: 16
    optional uint32                 delayedAckMS            = 78 [deprecated=true];           // [0, 127],          default value: 0
    optional uint32                 delayedAckWinDivShift   = 79 [deprecated=true];           // [0, 10],           default value: 3
    optional uint32                 delayedAckIdleMS        = 80 [deprecated=true];           // [500, 60000],      default value: 5000
    optional uint32                 pmtuRegrowMS            = 81 [deprecated=true];           // [0, 3600000],      default value: 600000
    optional uint32                 lttPmtuRegrowMS         = 82 [deprecated=true];           // [0, 3600000],      default value: 500000     not bigger than pmtuRegrowMS

    optional uint32                 packetWrapper           = 83 [deprecated=true];            //                   default value: Depend on platforms
    optional bool                   txCongestObey           = 84 [deprecated=true];            //                   default value: 1            0: feature off    1: feature on
    optional bool                   subnetAccEnable         = 85 [deprecated=true];            //                   default value: 0            0: feature off    1: feature on
    optional bool                   tcpOnly                 = 86 [deprecated=true];            //                   default value: 0(cpe) 1(lotwan/lotserver)     0: feature off    1: feature on
    optional uint32                 rtoMin                  = 87 [deprecated=true];            //                   default value: 3000(cpe) not support(lotwan/lotserver)
    optional IpFilters              ipFilters               = 88 [deprecated=true];            //                   default value: none
    optional uint32                 lttMaxFailRetries       = 89 [deprecated=true];            //                   default value: 100(cpe/lotserver) N/A(lotwan)
    optional uint32                 lttRtoMin               = 90 [deprecated=true];            //                   default value: 1000(cpe/lotserver) N/A(lotwan)
}

message PeerSitePolicyStateReport_C2O
{
    required bool      isAvailable = 1;
    required uint32    policyId    = 2; // the policy will only be zone5
}

message WifiStationStatusReport_C2O {
    repeated WifiStationStatusReport wifiStationStatusReport = 1;
}

message WifiStationStatusReport {
    required string                 ssid            = 1;
    required string                 ifname          = 2;
    optional int32                  signalStrength  = 3;  // dbm
}

message SecurityInstanceVFWSshInfo
{
    optional uint32                         privateIp = 1;
    optional uint32                         publicIp = 2;
    optional bytes                          privateIpv6 = 3;
    optional bytes                          publicIpv6 = 4;
    optional uint32                         sshPort = 5;

    optional string                         adminName = 6;
    optional string                         adminDefPassword = 7;
    optional string                         adminNewPassword = 8;

    optional string                         securityManagerName = 9;
    optional string                         securityManagerPassword = 10;
}

message SecurityInstanceVFWIntf
{
    optional Cidr                           workIpAddr = 1;
    optional Cidr                           greVirtualIpAddr = 2;
    optional uint32                         gateway = 3;

    optional Ipv6Cidr                       workIpv6Addr = 4;
    optional Ipv6Cidr                       greVirtualIpv6Addr = 5;
    optional bytes                          ipv6Gateway = 6;
}

message SecurityInstanceVFWLicense
{
    optional uint32                         ip = 1;
    optional bytes                          ipv6 = 2;
    required uint32                         port = 3;
    required string                         userName = 4;
    required string                         password = 5;
}

message SecurityInstanceVFW
{
    required string                         id = 1;
    required uint32                         customerId = 2;
    required string                         ifname = 3;

    optional SecurityInstanceVFWSshInfo     sshInfo = 4;
    optional SecurityInstanceVFWIntf        intfConf = 5;
    optional SecurityInstanceVFWLicense     licenseInfo = 6;
}

message SecurityInstanceGeneralParamItem
{
    required string                                 paramName = 1;
    required string                                 paramVal = 2;
}

message SecurityInstanceGeneralConfigure
{
    repeated SecurityInstanceGeneralParamItem       params = 1;
    optional string                                 scriptContent = 2;
    optional string                                 downloadUrl = 3;
    optional string                                 checksum = 4;
}

message SecurityInstanceGeneralCheck
{
    repeated SecurityInstanceGeneralParamItem       params = 1;
    optional string                                 scriptContent = 2;
    optional string                                 downloadUrl = 3;
    optional string                                 checksum = 4;
}

message SecurityInstanceGeneralUnit
{
    required string                                 id = 1;
    required uint32                                 customerId = 2;
    optional string                                 vendor = 3;
    optional string                                 ifname = 4;
    optional uint32                                 addr = 5;

    optional SecurityInstanceGeneralConfigure       configure = 6;
    optional SecurityInstanceGeneralCheck           check = 7;
}

message SecurityInstance
{
    required uint32                         type = 1;   //LW_SECURITY_INSTANCE_TYPE
    optional SecurityInstanceVFW            vFw = 2;
    optional SecurityInstanceGeneralUnit    generalUnit = 3;
}

message SecurityInstanceVFWStatus
{
    required string                         id = 1;
    required uint32                         customerId = 2;
    required uint32                         status = 3;     //LW_SECURITY_INSTANCE_VFW_STATUS
    optional string                         statusInfo = 4;
}

message SecurityInstanceGeneralUnitStatus
{
    required string                         id = 1;
    required uint32                         customerId = 2;
    required uint32                         status = 3;     //LW_SECURITY_INSTANCE_GU_STATUS
    optional string                         statusInfo = 4;
}

message SecurityInstanceStatusReport_C2O
{
    required uint32                             type = 1;   //LW_SECURITY_INSTANCE_TYPE
    optional SecurityInstanceVFWStatus          vFw = 2;
    optional SecurityInstanceGeneralUnitStatus  generalUnit = 3;
}

message SystemConf {
    required uint32                         type = 1;     // 1 for timezone 2 for ComwareCloudConfig
    optional TimeZone                       timeZone = 2;
    optional ComwareCloudConfig             comwareCloudConfig = 3;
}

message TimeZone {
    required sint32                         timeZoneGMTOffset = 1;
}

message AlarmInfo
{
    required uint32                         alarmMod     = 1; // LW_ALARM_MOD
    required uint32                         alarmCode    = 2;
}

message AlarmReport
{
    repeated AlarmInfo                      infos     = 1;
    optional uint64                         timestamp   = 2;   // send msg timestamp
}

message AlarmReport_C2O
{
    repeated AlarmReport                    reports = 1;
}

message RunningBypassConf
{
    required bool                           enable          = 1;    //0: disable 1: enable
    optional uint32                         interval        = 2;    //second, [1-255] default: 2s
    optional uint32                         timeout         = 3;    //second, [1-255] default: 5s
}

message HardwareBypassConf
{
    required bool                           switchBypass    = 1;    //0: no-bypass 1: bypass
    optional RunningBypassConf              runningBypassConf = 2;
}
message WanStaticRouteConf
{
    required uint32                 vpnId   = 1;
    repeated WanStaticRoute         wanRoute= 2;
    required uint64                 version = 3;
}

message WanStaticRoute
{
    required uint32                 addrType        = 1;        //1:ipv4 2:ipv6
    repeated IpType                 ipv4NetList     = 2;
    optional uint32                 ipv4NextHop     = 3;
    repeated Ipv6Type               ipv6NetList     = 4;
    optional bytes                  ipv6NextHop     = 5;
}
